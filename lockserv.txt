	(mode: frpo)
	(reuse: 1)
	(opt: 1)
	(const: 1)
	(wires: 1)
@     0s  Reading from file output/test/test.vmt
-----------------------------------------------------------------

Action inputs:
	ext:recv_lock: set([V__fml:sender])
	ext:unlock: set([V__fml:n])
	ext:recv_unlock: set([V__fml:sender])
	ext:lock: set([V__fml:n])
	ext:recv_grant: set([V__fml:n])

Action definitions:
	ext:recv_lock: {}
	ext:unlock: {}
	ext:recv_unlock: {}
	ext:lock: {}
	ext:recv_grant: {}

Action preconditions:

	ext:recv_lock:
		~__held
		__lock_msg(V__fml:sender)

	ext:unlock:
		__holds_lock(V__fml:n)

	ext:recv_unlock:
		__unlock_msg(V__fml:sender)

	ext:lock:

	ext:recv_grant:
		__grant_msg(V__fml:n)

Action postconditions:

	ext:recv_lock:
		held
		(forall V0 . (lock_msg(V0) <-> ((V0 = V__fml:sender) ? False : __lock_msg(V0))))
		(forall V0 . (grant_msg(V0) <-> ((V0 = V__fml:sender) ? True : __grant_msg(V0))))

	ext:unlock:
		(forall V0 . (holds_lock(V0) <-> ((V0 = V__fml:n) ? False : __holds_lock(V0))))
		(forall V0 . (unlock_msg(V0) <-> ((V0 = V__fml:n) ? True : __unlock_msg(V0))))

	ext:recv_unlock:
		(forall V0 . (unlock_msg(V0) <-> ((V0 = V__fml:sender) ? False : __unlock_msg(V0))))
		~held

	ext:lock:
		(forall V0 . (lock_msg(V0) <-> ((V0 = V__fml:n) ? True : __lock_msg(V0))))

	ext:recv_grant:
		(forall V0 . (holds_lock(V0) <-> ((V0 = V__fml:n) ? True : __holds_lock(V0))))
		(forall V0 . (grant_msg(V0) <-> ((V0 = V__fml:n) ? False : __grant_msg(V0))))

Update map:
	grant_msg ->  ext:recv_lock ext:recv_grant
	held ->  ext:recv_unlock ext:recv_lock
	holds_lock ->  ext:unlock ext:recv_grant
	lock_msg ->  ext:lock ext:recv_lock
	unlock_msg ->  ext:recv_unlock ext:unlock

stratifying state variables:

stratifying axioms:

stratifying action ext:lock:

stratifying action ext:recv_unlock:

stratifying action ext:recv_lock:

stratifying action ext:unlock:

stratifying action ext:recv_grant:

stratifying property:
    pos:
    neg:
	(epr: True)

stratifying helpers:

Arcs:

EPR: True
-----------------------------------------------------------------
	(gen: fef)
-----------------------------------------------------------------
	(found #5 actions)
adding #4 noops to action ext:lock
	noop(grant_msg)
	noop(held)
	noop(holds_lock)
	noop(unlock_msg)
adding #3 noops to action ext:recv_unlock
	noop(grant_msg)
	noop(holds_lock)
	noop(lock_msg)
adding #2 noops to action ext:recv_lock
	noop(holds_lock)
	noop(unlock_msg)
adding #3 noops to action ext:unlock
	noop(grant_msg)
	noop(held)
	noop(lock_msg)
adding #3 noops to action ext:recv_grant
	noop(held)
	noop(lock_msg)
	noop(unlock_msg)
-----------------------------------------------------------------
Init #1
	((forall V0 . ~__lock_msg(V0)) & (forall V0 . ~__unlock_msg(V0)) & (forall V0 . ~__grant_msg(V0)) & (forall V0 . ~__holds_lock(V0)) & ~__held)
		with variables frozenset([__unlock_msg, __grant_msg, __held, __holds_lock, __lock_msg])

Axioms #0

Actions #6
	0:	ext:lock (en: en_ext:lock)	((forall V0 . (lock_msg(V0) <-> ((... = ...) ? True : ...(...)))) & (forall 1:node . (__grant_msg(1:node) <-> grant_msg(1:node))) & (__held <-> held) & (forall 1:node . (__holds_lock(1:node) <-> holds_lock(1:node))) & (forall 1:node . (__unlock_msg(1:node) <-> unlock_msg(1:node))))
		with variables frozenset([__grant_msg, __held, __holds_lock, __lock_msg, __unlock_msg, grant_msg, held, holds_lock, lock_msg, V__fml:n, unlock_msg])
	1:	ext:recv_unlock (en: en_ext:recv_unlock)	(((forall V0 . (...(...) <-> (... ? ... : ...))) & ~held & __unlock_msg(V__fml:sender)) & (forall 1:node . (__grant_msg(1:node) <-> grant_msg(1:node))) & (forall 1:node . (__holds_lock(1:node) <-> holds_lock(1:node))) & (forall 1:node . (__lock_msg(1:node) <-> lock_msg(1:node))))
		with variables frozenset([__grant_msg, __holds_lock, __lock_msg, __unlock_msg, grant_msg, held, holds_lock, lock_msg, unlock_msg, V__fml:sender])
	2:	ext:recv_lock (en: en_ext:recv_lock)	((held & (forall V0 . (...(...) <-> (... ? ... : ...))) & (forall V0 . (...(...) <-> (... ? ... : ...))) & __lock_msg(V__fml:sender) & ~__held) & (forall 1:node . (__holds_lock(1:node) <-> holds_lock(1:node))) & (forall 1:node . (__unlock_msg(1:node) <-> unlock_msg(1:node))))
		with variables frozenset([__grant_msg, __held, __holds_lock, __lock_msg, __unlock_msg, grant_msg, held, holds_lock, lock_msg, unlock_msg, V__fml:sender])
	3:	ext:unlock (en: en_ext:unlock)	(((forall V0 . (...(...) <-> (... ? ... : ...))) & (forall V0 . (...(...) <-> (... ? ... : ...))) & __holds_lock(V__fml:n)) & (forall 1:node . (__grant_msg(1:node) <-> grant_msg(1:node))) & (__held <-> held) & (forall 1:node . (__lock_msg(1:node) <-> lock_msg(1:node))))
		with variables frozenset([__grant_msg, __held, __holds_lock, __lock_msg, __unlock_msg, grant_msg, held, holds_lock, lock_msg, V__fml:n, unlock_msg])
	4:	ext:recv_grant (en: en_ext:recv_grant)	(((forall V0 . (...(...) <-> (... ? ... : ...))) & (forall V0 . (...(...) <-> (... ? ... : ...))) & __grant_msg(V__fml:n)) & (__held <-> held) & (forall 1:node . (__lock_msg(1:node) <-> lock_msg(1:node))) & (forall 1:node . (__unlock_msg(1:node) <-> unlock_msg(1:node))))
		with variables frozenset([__grant_msg, __held, __holds_lock, __lock_msg, __unlock_msg, grant_msg, held, holds_lock, lock_msg, V__fml:n, unlock_msg])
	5:	noop (en: en_noop)	((forall 1:node . (__grant_msg(1:node) <-> grant_msg(1:node))) & (__held <-> held) & (forall 1:node . (__holds_lock(1:node) <-> holds_lock(1:node))) & (forall 1:node . (__lock_msg(1:node) <-> lock_msg(1:node))) & (forall 1:node . (__unlock_msg(1:node) <-> unlock_msg(1:node))))
		with variables frozenset([__grant_msg, __held, __holds_lock, __lock_msg, __unlock_msg, grant_msg, held, holds_lock, lock_msg, unlock_msg])

Properties #1
	(forall X, Y . ((__holds_lock(X) & __holds_lock(Y)) -> (X = Y)))
		with variables frozenset([__holds_lock])

Variables #12
	__grant_msg of type node -> Bool
	__held of type Bool
	__holds_lock of type node -> Bool
	__lock_msg of type node -> Bool
	__unlock_msg of type node -> Bool
	grant_msg of type node -> Bool
	held of type Bool
	holds_lock of type node -> Bool
	lock_msg of type node -> Bool
	V__fml:n of type node
	unlock_msg of type node -> Bool
	V__fml:sender of type node

State variables #5
	__unlock_msg of type node -> Bool
	__grant_msg of type node -> Bool
	__held of type Bool
	__holds_lock of type node -> Bool
	__lock_msg of type node -> Bool

Nex state variables #5
	grant_msg of type node -> Bool
	held of type Bool
	holds_lock of type node -> Bool
	lock_msg of type node -> Bool
	unlock_msg of type node -> Bool

Global variables #0

Ordered variables #0

Nex to pre #5
	grant_msg <- __grant_msg
	held <- __held
	holds_lock <- __holds_lock
	lock_msg <- __lock_msg
	unlock_msg <- __unlock_msg

Pre to nex #5
	__unlock_msg -> unlock_msg
	__grant_msg -> grant_msg
	__held -> held
	__holds_lock -> holds_lock
	__lock_msg -> lock_msg

Other variables #2
	V__fml:n of type node
	V__fml:sender of type node

Axiom variables #0

Predicates #0

Helpers #0

Inferences #0

Definitions #0

Definition Map #0

Trel:
((en_ext:lock -> ((forall V0 . (lock_msg(V0) <-> ((V0 = V__fml:n) ? True : __lock_msg(V0)))) & (forall 1:node . (__grant_msg(1:node) <-> grant_msg(1:node))) & (__held <-> held) & (forall 1:node . (__holds_lock(1:node) <-> holds_lock(1:node))) & (forall 1:node . (__unlock_msg(1:node) <-> unlock_msg(1:node))))) & (en_ext:recv_unlock -> (((forall V0 . (unlock_msg(V0) <-> ((V0 = V__fml:sender) ? False : __unlock_msg(V0)))) & ~held & __unlock_msg(V__fml:sender)) & (forall 1:node . (__grant_msg(1:node) <-> grant_msg(1:node))) & (forall 1:node . (__holds_lock(1:node) <-> holds_lock(1:node))) & (forall 1:node . (__lock_msg(1:node) <-> lock_msg(1:node))))) & (en_ext:recv_lock -> ((held & (forall V0 . (lock_msg(V0) <-> ((V0 = V__fml:sender) ? False : __lock_msg(V0)))) & (forall V0 . (grant_msg(V0) <-> ((V0 = V__fml:sender) ? True : __grant_msg(V0)))) & __lock_msg(V__fml:sender) & ~__held) & (forall 1:node . (__holds_lock(1:node) <-> holds_lock(1:node))) & (forall 1:node . (__unlock_msg(1:node) <-> unlock_msg(1:node))))) & (en_ext:unlock -> (((forall V0 . (holds_lock(V0) <-> ((V0 = V__fml:n) ? False : __holds_lock(V0)))) & (forall V0 . (unlock_msg(V0) <-> ((V0 = V__fml:n) ? True : __unlock_msg(V0)))) & __holds_lock(V__fml:n)) & (forall 1:node . (__grant_msg(1:node) <-> grant_msg(1:node))) & (__held <-> held) & (forall 1:node . (__lock_msg(1:node) <-> lock_msg(1:node))))) & (en_ext:recv_grant -> (((forall V0 . (grant_msg(V0) <-> ((V0 = V__fml:n) ? False : __grant_msg(V0)))) & (forall V0 . (holds_lock(V0) <-> ((V0 = V__fml:n) ? True : __holds_lock(V0)))) & __grant_msg(V__fml:n)) & (__held <-> held) & (forall 1:node . (__lock_msg(1:node) <-> lock_msg(1:node))) & (forall 1:node . (__unlock_msg(1:node) <-> unlock_msg(1:node))))) & (en_noop -> ((forall 1:node . (__grant_msg(1:node) <-> grant_msg(1:node))) & (__held <-> held) & (forall 1:node . (__holds_lock(1:node) <-> holds_lock(1:node))) & (forall 1:node . (__lock_msg(1:node) <-> lock_msg(1:node))) & (forall 1:node . (__unlock_msg(1:node) <-> unlock_msg(1:node))))) & (en_ext:lock | en_ext:recv_unlock | en_ext:recv_lock | en_ext:unlock | en_ext:recv_grant | en_noop) & (~en_ext:lock | ~en_ext:recv_unlock) & (~en_ext:lock | ~en_ext:recv_lock) & (~en_ext:lock | ~en_ext:unlock) & (~en_ext:lock | ~en_ext:recv_grant) & (~en_ext:lock | ~en_noop) & (~en_ext:recv_unlock | ~en_ext:recv_lock) & (~en_ext:recv_unlock | ~en_ext:unlock) & (~en_ext:recv_unlock | ~en_ext:recv_grant) & (~en_ext:recv_unlock | ~en_noop) & (~en_ext:recv_lock | ~en_ext:unlock) & (~en_ext:recv_lock | ~en_ext:recv_grant) & (~en_ext:recv_lock | ~en_noop) & (~en_ext:unlock | ~en_ext:recv_grant) & (~en_ext:unlock | ~en_noop) & (~en_ext:recv_grant | ~en_noop))
-----------------------------------------------------------------
(enumsort) node <-> node:e0:
	[ NODE0, ] <-> [ n0, ]
	dep_height[n0] = 0
	(running: frpo)
@     0s  (building bdds for ext:lock)
adding varbool: held:e0 := held:e0 <-> 4
adding varbool: __held:e0 := __held:e0 <-> 5
@     0s  (building bdds for ext:recv_unlock)
@     0s  (building bdds for ext:recv_lock)
@     0s  (building bdds for ext:unlock)
@     0s  (building bdds for ext:recv_grant)
adding varbool: en_noop:e0 := en_noop:e0 <-> 12
adding varbool: en_ext:recv_grant:e0 := en_ext:recv_grant:e0 <-> 13
adding varbool: en_ext:unlock:e0 := en_ext:unlock:e0 <-> 14
adding varbool: en_ext:recv_lock:e0 := en_ext:recv_lock:e0 <-> 15
adding varbool: en_ext:recv_unlock:e0 := en_ext:recv_unlock:e0 <-> 16
adding varbool: en_ext:lock:e0 := en_ext:lock:e0 <-> 17
adding pre: __holds_lock:e0(`node:e0:0`) with bdd 3
adding pre: __grant_msg:e0(`node:e0:0`) with bdd 7
adding pre: __unlock_msg:e0(`node:e0:0`) with bdd 1
adding pre: __lock_msg:e0(`node:e0:0`) with bdd 8
adding pre: __held:e0 with bdd 5
	(#18 variables)
processing __unlock_msg
adding pre: __unlock_msg(n0) <-> _func2 := 1
processing __lock_msg
adding pre: __lock_msg(n0) <-> _func7 := 8
processing __holds_lock
adding pre: __holds_lock(n0) <-> _func4 := 3
processing __grant_msg
adding pre: __grant_msg(n0) <-> _func6 := 7
processing __held:e0
adding pre: __held:e0 <-> __held:e0 := 5
	(#10 atoms with #18 variables)
0 -> unlock_msg(n0)
1 -> __unlock_msg(n0)
2 -> holds_lock(n0)
3 -> __holds_lock(n0)
4 -> held:e0
5 -> __held:e0
6 -> grant_msg(n0)
7 -> __grant_msg(n0)
8 -> __lock_msg(n0)
9 -> (V__fml:n = n0)
10 -> lock_msg(n0)
11 -> (V__fml:sender = n0)
12 -> en_noop:e0
13 -> en_ext:recv_grant:e0
14 -> en_ext:unlock:e0
15 -> en_ext:recv_lock:e0
16 -> en_ext:recv_unlock:e0
17 -> en_ext:lock:e0
DECLARE_STATES
__grant_msg:e0(`node:e0:0`)
__held:e0(`node:e0:0`)
__unlock_msg:e0(`node:e0:0`)
__lock_msg:e0(`node:e0:0`)
__holds_lock:e0(`node:e0:0`)
BEGIN_VARLABELS
0	unlock_msg:e0(`node:e0:0`)
1	__unlock_msg:e0(`node:e0:0`)
2	holds_lock:e0(`node:e0:0`)
3	__holds_lock:e0(`node:e0:0`)
4	held:e0
5	__held:e0
6	grant_msg:e0(`node:e0:0`)
7	__grant_msg:e0(`node:e0:0`)
8	__lock_msg:e0(`node:e0:0`)
9	(V__fml:n:e0 = `node:e0:0`)
10	lock_msg:e0(`node:e0:0`)
11	(V__fml:sender:e0 = `node:e0:0`)
12	en_noop:e0
13	en_ext:recv_grant:e0
14	en_ext:unlock:e0
15	en_ext:recv_lock:e0
16	en_ext:recv_unlock:e0
17	en_ext:lock:e0
END_VARLABELS
-0-0-0-00---------  1
-0-0-0-0----------  1
-0-0-0-00---------  1
-0-0-1-10---------  1
-0-0-0-01---------  1
-0-0-0-00---------  1
-0-1-1-00---------  1
-0-0-1-10---------  1
-0-0-0-01---------  1
-0-0-1-11---------  1
-0-0-0-00---------  1
-1-0-1-00---------  1
-0-1-1-00---------  1
-0-0-1-10---------  1
-0-0-0-01---------  1
-0-1-1-01---------  1
-0-0-1-11---------  1
-0-0-0-0----------  1
-1-0-1-0----------  1
-0-1-1-0----------  1
-0-0-1-1----------  1
-0-0-0-0----------  1
-1-0-1-0----------  1
-0-1-1-0----------  1
-0-0-1-1----------  1
-0-0-0-0----------  1
-1-0-1-0----------  1
-0-1-1-0----------  1
-0-0-1-1----------  1
