# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
PyCUDD 2.0.3
Python interface to Colorado University Decision Diagram package
With BREL support
Copyright (c) 2014, The Regents of the University of California
All rights reserved.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Compiled on Sep 13 2022, 13:20:00
Bugs to:forrest@ece.ucsb.edu
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _repycudd
else:
    import _repycudd

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


DOCSTRING = _repycudd.DOCSTRING
@_swig_add_metaclass(_SwigNonDynamicMeta)
class RangeError(object):
    r"""Proxy of C++ RangeError class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(RangeError self) -> RangeError"""
        _repycudd.RangeError_swiginit(self, _repycudd.new_RangeError())
    __swig_destroy__ = _repycudd.delete_RangeError

# Register RangeError in _repycudd:
_repycudd.RangeError_swigregister(RangeError)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class IntArray(object):
    r"""Proxy of C++ IntArray class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    vec = property(_repycudd.IntArray_vec_get, _repycudd.IntArray_vec_set, doc=r"""vec : p.int""")

    def __init__(self, size):
        r"""__init__(IntArray self, int size) -> IntArray"""
        _repycudd.IntArray_swiginit(self, _repycudd.new_IntArray(size))
    __swig_destroy__ = _repycudd.delete_IntArray

    def AssignVect(self, str, size):
        r"""AssignVect(IntArray self, int * str, int size)"""
        return _repycudd.IntArray_AssignVect(self, str, size)

    def AssignComplVect(self, str, size, univ):
        r"""AssignComplVect(IntArray self, int * str, int size, int univ)"""
        return _repycudd.IntArray_AssignComplVect(self, str, size, univ)

    def ArrayAddress(self):
        r"""ArrayAddress(IntArray self) -> int **"""
        return _repycudd.IntArray_ArrayAddress(self)

    def __getitem__(self, j):
        r"""__getitem__(IntArray self, int j) -> int"""
        return _repycudd.IntArray___getitem__(self, j)

    def __setitem__(self, j, val):
        r"""__setitem__(IntArray self, int j, int val)"""
        return _repycudd.IntArray___setitem__(self, j, val)

    def __len__(self):
        r"""__len__(IntArray self) -> int"""
        return _repycudd.IntArray___len__(self)

    def Assign(self, list, k):
        r"""Assign(IntArray self, int * list, int k)"""
        return _repycudd.IntArray_Assign(self, list, k)

    def Swap(self, i, j):
        r"""Swap(IntArray self, int i, int j)"""
        return _repycudd.IntArray_Swap(self, i, j)

# Register IntArray in _repycudd:
_repycudd.IntArray_swigregister(IntArray)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class StringArray(object):
    r"""Proxy of C++ StringArray class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    vec = property(_repycudd.StringArray_vec_get, _repycudd.StringArray_vec_set, doc=r"""vec : p.p.char""")

    def __init__(self, size):
        r"""__init__(StringArray self, int size) -> StringArray"""
        _repycudd.StringArray_swiginit(self, _repycudd.new_StringArray(size))
    __swig_destroy__ = _repycudd.delete_StringArray

    def ArrayAddress(self):
        r"""ArrayAddress(StringArray self) -> char ***"""
        return _repycudd.StringArray_ArrayAddress(self)

    def __getitem__(self, j):
        r"""__getitem__(StringArray self, int j) -> char *"""
        return _repycudd.StringArray___getitem__(self, j)

    def __setitem__(self, j, val):
        r"""__setitem__(StringArray self, int j, char * val)"""
        return _repycudd.StringArray___setitem__(self, j, val)

    def __len__(self):
        r"""__len__(StringArray self) -> int"""
        return _repycudd.StringArray___len__(self)

    def Assign(self, list, k):
        r"""Assign(StringArray self, char ** list, int k)"""
        return _repycudd.StringArray_Assign(self, list, k)

    def Swap(self, i, j):
        r"""Swap(StringArray self, int i, int j)"""
        return _repycudd.StringArray_Swap(self, i, j)

# Register StringArray in _repycudd:
_repycudd.StringArray_swigregister(StringArray)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class DoubleArray(object):
    r"""Proxy of C++ DoubleArray class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    vec = property(_repycudd.DoubleArray_vec_get, _repycudd.DoubleArray_vec_set, doc=r"""vec : p.double""")

    def __init__(self, size):
        r"""__init__(DoubleArray self, int size) -> DoubleArray"""
        _repycudd.DoubleArray_swiginit(self, _repycudd.new_DoubleArray(size))
    __swig_destroy__ = _repycudd.delete_DoubleArray

    def __getitem__(self, j):
        r"""__getitem__(DoubleArray self, int j) -> double"""
        return _repycudd.DoubleArray___getitem__(self, j)

    def __setitem__(self, j, val):
        r"""__setitem__(DoubleArray self, int j, double val)"""
        return _repycudd.DoubleArray___setitem__(self, j, val)

    def Assign(self, list, k):
        r"""Assign(DoubleArray self, double * list, int k)"""
        return _repycudd.DoubleArray_Assign(self, list, k)

    def Swap(self, i, j):
        r"""Swap(DoubleArray self, int i, int j)"""
        return _repycudd.DoubleArray_Swap(self, i, j)

# Register DoubleArray in _repycudd:
_repycudd.DoubleArray_swigregister(DoubleArray)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class DdArray(object):
    r"""Proxy of C++ DdArray class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    __doc__ = "This class provides an array of DdNodes. This is an addition to the CUDD package. Create a DdArray by calling the constructor with the length of the array. In terms of Python array-like behaviour, you can index it, assign individual elements and take its length. Typically, these arrays are populated via the Push method. Refer pycudd.h and pycudd.cpp for function details.<br>"

    sz = property(_repycudd.DdArray_sz_get, _repycudd.DdArray_sz_set, doc=r"""sz : int""")
    vec = property(_repycudd.DdArray_vec_get, _repycudd.DdArray_vec_set, doc=r"""vec : p.p.DdNode""")
    mgr = property(_repycudd.DdArray_mgr_get, _repycudd.DdArray_mgr_set, doc=r"""mgr : p.DdManager""")

    def __init__(self, ddman, size):
        r"""__init__(DdArray self, DdManager ddman, int size) -> DdArray"""
        _repycudd.DdArray_swiginit(self, _repycudd.new_DdArray(ddman, size))
    __swig_destroy__ = _repycudd.delete_DdArray

    def __getitem__(self, j):
        r"""__getitem__(DdArray self, int j) -> DdNode"""
        return _repycudd.DdArray___getitem__(self, j)

    def __setitem__(self, j, val):
        r"""__setitem__(DdArray self, int j, DdNode val)"""
        return _repycudd.DdArray___setitem__(self, j, val)

    def __len__(self):
        r"""__len__(DdArray self) -> int"""
        return _repycudd.DdArray___len__(self)

    def Swap(self, i, j):
        r"""Swap(DdArray self, int i, int j)"""
        return _repycudd.DdArray_Swap(self, i, j)

    def Pop(self):
        r"""Pop(DdArray self) -> DdNode"""
        return _repycudd.DdArray_Pop(self)

    def And(self):
        r"""And(DdArray self) -> DdNode"""
        return _repycudd.DdArray_And(self)

    def Or(self):
        r"""Or(DdArray self) -> DdNode"""
        return _repycudd.DdArray_Or(self)

    def AtLeastN(self, n):
        r"""AtLeastN(DdArray self, int n) -> DdNode"""
        return _repycudd.DdArray_AtLeastN(self, n)

    def ExactlyN(self, n):
        r"""ExactlyN(DdArray self, int n) -> DdNode"""
        return _repycudd.DdArray_ExactlyN(self, n)

    def UpToN(self, n):
        r"""UpToN(DdArray self, int n) -> DdNode"""
        return _repycudd.DdArray_UpToN(self, n)

    def Constraint(self, low, high):
        r"""Constraint(DdArray self, int low, int high) -> DdNode"""
        return _repycudd.DdArray_Constraint(self, low, high)

    def Compose(self, term):
        r"""Compose(DdArray self, DdNode term) -> DdNode"""
        return _repycudd.DdArray_Compose(self, term)

    def Assign(self, list, k):
        r"""Assign(DdArray self, DdNode ** list, int k)"""
        return _repycudd.DdArray_Assign(self, list, k)

    def Push(self, val):
        r"""Push(DdArray self, DdNode val)"""
        return _repycudd.DdArray_Push(self, val)

    def SwapNodes(self, i, j):
        r"""SwapNodes(DdArray self, int i, int j)"""
        return _repycudd.DdArray_SwapNodes(self, i, j)

    def Fill(self, offset, mod):
        r"""Fill(DdArray self, int offset, int mod)"""
        return _repycudd.DdArray_Fill(self, offset, mod)

    def FillWithIntArray(self, t):
        r"""FillWithIntArray(DdArray self, IntArray t)"""
        return _repycudd.DdArray_FillWithIntArray(self, t)

    def OrderVector(self, left, right):
        r"""OrderVector(DdArray self, int left, int right)"""
        return _repycudd.DdArray_OrderVector(self, left, right)

    def SupportVector(self, term):
        r"""SupportVector(DdArray self, DdNode term)"""
        return _repycudd.DdArray_SupportVector(self, term)

    def SetVarMap(self, other):
        r"""SetVarMap(DdArray self, DdArray other) -> int"""
        return _repycudd.DdArray_SetVarMap(self, other)

    def VectorSupport(self):
        r"""VectorSupport(DdArray self) -> DdNode"""
        return _repycudd.DdArray_VectorSupport(self)

    def VectorSupportIndex(self):
        r"""VectorSupportIndex(DdArray self) -> int"""
        return _repycudd.DdArray_VectorSupportIndex(self)

    def PickOneMinterm(self, term):
        r"""PickOneMinterm(DdArray self, DdNode term) -> DdNode"""
        return _repycudd.DdArray_PickOneMinterm(self, term)

    def HoldTR(self, other):
        r"""HoldTR(DdArray self, DdArray other) -> DdNode"""
        return _repycudd.DdArray_HoldTR(self, other)

    def Find(self, term):
        r"""Find(DdArray self, DdNode term) -> int"""
        return _repycudd.DdArray_Find(self, term)

    def Save(self, filename):
        r"""Save(DdArray self, char * filename) -> int"""
        return _repycudd.DdArray_Save(self, filename)

    def SaveText(self, filename):
        r"""SaveText(DdArray self, char * filename) -> int"""
        return _repycudd.DdArray_SaveText(self, filename)

    def Load(self, filename):
        r"""Load(DdArray self, char * filename) -> int"""
        return _repycudd.DdArray_Load(self, filename)

    def LoadText(self, filename):
        r"""LoadText(DdArray self, char * filename) -> int"""
        return _repycudd.DdArray_LoadText(self, filename)

    def ArrayLoad(self, rootmatchmode, rootmatchnames, varmatchmode, varmatchnames, varmatchauxids, varcomposeids, mode, filename, fp=None):
        r"""ArrayLoad(DdArray self, int rootmatchmode, StringArray rootmatchnames, int varmatchmode, StringArray varmatchnames, IntArray varmatchauxids, IntArray varcomposeids, int mode, char * filename, FILE * fp=None) -> int"""
        return _repycudd.DdArray_ArrayLoad(self, rootmatchmode, rootmatchnames, varmatchmode, varmatchnames, varmatchauxids, varcomposeids, mode, filename, fp)

    def ArrayStore(self, ddname, rootnames, varnames, auxids, mode, varinfo, filename, fp=None):
        r"""ArrayStore(DdArray self, char * ddname, StringArray rootnames, StringArray varnames, IntArray auxids, int mode, int varinfo, char * filename, FILE * fp=None) -> int"""
        return _repycudd.DdArray_ArrayStore(self, ddname, rootnames, varnames, auxids, mode, varinfo, filename, fp)

# Register DdArray in _repycudd:
_repycudd.DdArray_swigregister(DdArray)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class MtrNode(object):
    r"""Proxy of C++ MtrNode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(MtrNode self) -> MtrNode"""
        _repycudd.MtrNode_swiginit(self, _repycudd.new_MtrNode())
    __swig_destroy__ = _repycudd.delete_MtrNode

# Register MtrNode in _repycudd:
_repycudd.MtrNode_swigregister(MtrNode)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class DdTlcInfo(object):
    r"""Proxy of C++ DdTlcInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    __doc__ = "Helper class for enumeration of two literal clauses. Look at example2.py for usage."


    def __init__(self):
        r"""__init__(DdTlcInfo self) -> DdTlcInfo"""
        _repycudd.DdTlcInfo_swiginit(self, _repycudd.new_DdTlcInfo())
    __swig_destroy__ = _repycudd.delete_DdTlcInfo

    def ReadIthClause(self, i):
        r"""ReadIthClause(DdTlcInfo self, int i) -> int"""
        return _repycudd.DdTlcInfo_ReadIthClause(self, i)

# Register DdTlcInfo in _repycudd:
_repycudd.DdTlcInfo_swigregister(DdTlcInfo)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class EpDouble(object):
    r"""Proxy of C++ EpDouble class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    __doc__ = "This provides the functionality of CUDD's extended precision library. In particular, instances of EpDouble may be passed to DdNode.EpdCountMinterm to retrieve the extended counts. Note also that the basic arithmetic operators (+,-,*,/) have been overloaded for use with EpDouble instances"


    def __init__(self, *args):
        r"""
        __init__(EpDouble self) -> EpDouble
        __init__(EpDouble self, double value) -> EpDouble
        __init__(EpDouble self, EpDouble value) -> EpDouble
        """
        _repycudd.EpDouble_swiginit(self, _repycudd.new_EpDouble(*args))
    __swig_destroy__ = _repycudd.delete_EpDouble

    def EpdConvert(self, value):
        r"""EpdConvert(EpDouble self, double value)"""
        return _repycudd.EpDouble_EpdConvert(self, value)

    def EpdNormalize(self):
        r"""EpdNormalize(EpDouble self)"""
        return _repycudd.EpDouble_EpdNormalize(self)

    def EpdNormalizeDecimal(self):
        r"""EpdNormalizeDecimal(EpDouble self)"""
        return _repycudd.EpDouble_EpdNormalizeDecimal(self)

    def EpdMakeInf(self, sign):
        r"""EpdMakeInf(EpDouble self, int sign)"""
        return _repycudd.EpDouble_EpdMakeInf(self, sign)

    def EpdMakeZero(self, sign):
        r"""EpdMakeZero(EpDouble self, int sign)"""
        return _repycudd.EpDouble_EpdMakeZero(self, sign)

    def EpdMakeNan(self):
        r"""EpdMakeNan(EpDouble self)"""
        return _repycudd.EpDouble_EpdMakeNan(self)

    def EpdCopy(self, to):
        r"""EpdCopy(EpDouble self, EpDouble to)"""
        return _repycudd.EpDouble_EpdCopy(self, to)

    def EpdGetValueAndDecimalExponent(self):
        r"""EpdGetValueAndDecimalExponent(EpDouble self)"""
        return _repycudd.EpDouble_EpdGetValueAndDecimalExponent(self)

    def EpdMultiply(self, value):
        r"""EpdMultiply(EpDouble self, double value)"""
        return _repycudd.EpDouble_EpdMultiply(self, value)

    def EpdMultiply2(self, epd2):
        r"""EpdMultiply2(EpDouble self, EpDouble epd2)"""
        return _repycudd.EpDouble_EpdMultiply2(self, epd2)

    def EpdMultiply2Decimal(self, epd2):
        r"""EpdMultiply2Decimal(EpDouble self, EpDouble epd2)"""
        return _repycudd.EpDouble_EpdMultiply2Decimal(self, epd2)

    def EpdMultiply3(self, epd2, epd3):
        r"""EpdMultiply3(EpDouble self, EpDouble epd2, EpDouble epd3)"""
        return _repycudd.EpDouble_EpdMultiply3(self, epd2, epd3)

    def EpdMultiply3Decimal(self, epd2, epd3):
        r"""EpdMultiply3Decimal(EpDouble self, EpDouble epd2, EpDouble epd3)"""
        return _repycudd.EpDouble_EpdMultiply3Decimal(self, epd2, epd3)

    def EpdDivide(self, value):
        r"""EpdDivide(EpDouble self, double value)"""
        return _repycudd.EpDouble_EpdDivide(self, value)

    def EpdDivide2(self, epd2):
        r"""EpdDivide2(EpDouble self, EpDouble epd2)"""
        return _repycudd.EpDouble_EpdDivide2(self, epd2)

    def EpdDivide3(self, epd2, epd3):
        r"""EpdDivide3(EpDouble self, EpDouble epd2, EpDouble epd3)"""
        return _repycudd.EpDouble_EpdDivide3(self, epd2, epd3)

    def EpdAdd(self, value):
        r"""EpdAdd(EpDouble self, double value)"""
        return _repycudd.EpDouble_EpdAdd(self, value)

    def EpdAdd2(self, epd2):
        r"""EpdAdd2(EpDouble self, EpDouble epd2)"""
        return _repycudd.EpDouble_EpdAdd2(self, epd2)

    def EpdAdd3(self, epd2, epd3):
        r"""EpdAdd3(EpDouble self, EpDouble epd2, EpDouble epd3)"""
        return _repycudd.EpDouble_EpdAdd3(self, epd2, epd3)

    def EpdSubtract(self, value):
        r"""EpdSubtract(EpDouble self, double value)"""
        return _repycudd.EpDouble_EpdSubtract(self, value)

    def EpdSubtract2(self, epd2):
        r"""EpdSubtract2(EpDouble self, EpDouble epd2)"""
        return _repycudd.EpDouble_EpdSubtract2(self, epd2)

    def EpdSubtract3(self, epd2, epd3):
        r"""EpdSubtract3(EpDouble self, EpDouble epd2, EpDouble epd3)"""
        return _repycudd.EpDouble_EpdSubtract3(self, epd2, epd3)

    def EpdPow2(self, n):
        r"""EpdPow2(EpDouble self, int n)"""
        return _repycudd.EpDouble_EpdPow2(self, n)

    def EpdPow2Decimal(self, n):
        r"""EpdPow2Decimal(EpDouble self, int n)"""
        return _repycudd.EpDouble_EpdPow2Decimal(self, n)

    def __add__(self, *args):
        r"""
        __add__(EpDouble self, EpDouble other) -> EpDouble
        __add__(EpDouble self, double other) -> EpDouble
        """
        return _repycudd.EpDouble___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(EpDouble self, EpDouble other) -> EpDouble
        __sub__(EpDouble self, double other) -> EpDouble
        """
        return _repycudd.EpDouble___sub__(self, *args)

    def __mul__(self, *args):
        r"""
        __mul__(EpDouble self, EpDouble other) -> EpDouble
        __mul__(EpDouble self, double other) -> EpDouble
        """
        return _repycudd.EpDouble___mul__(self, *args)

    def __div__(self, *args):
        r"""
        __div__(EpDouble self, EpDouble other) -> EpDouble
        __div__(EpDouble self, double other) -> EpDouble
        """
        return _repycudd.EpDouble___div__(self, *args)

    def EpdCmp(self, other):
        r"""EpdCmp(EpDouble self, EpDouble other) -> bool"""
        return _repycudd.EpDouble_EpdCmp(self, other)

    def EpdIsInf(self):
        r"""EpdIsInf(EpDouble self) -> bool"""
        return _repycudd.EpDouble_EpdIsInf(self)

    def EpdIsZero(self):
        r"""EpdIsZero(EpDouble self) -> bool"""
        return _repycudd.EpDouble_EpdIsZero(self)

    def EpdIsNan(self):
        r"""EpdIsNan(EpDouble self) -> bool"""
        return _repycudd.EpDouble_EpdIsNan(self)

    def EpdIsNanOrInf(self):
        r"""EpdIsNanOrInf(EpDouble self) -> bool"""
        return _repycudd.EpDouble_EpdIsNanOrInf(self)

    def __nonzero__(self):
        r"""__nonzero__(EpDouble self) -> bool"""
        return _repycudd.EpDouble___nonzero__(self)

    def __eq__(self, other):
        r"""__eq__(EpDouble self, EpDouble other) -> bool"""
        return _repycudd.EpDouble___eq__(self, other)

    def __ne__(self, other):
        r"""__ne__(EpDouble self, EpDouble other) -> bool"""
        return _repycudd.EpDouble___ne__(self, other)

# Register EpDouble in _repycudd:
_repycudd.EpDouble_swigregister(EpDouble)


def EpdGetExponent(value):
    r"""EpdGetExponent(double value) -> int"""
    return _repycudd.EpdGetExponent(value)

def EpdGetExponentDecimal(value):
    r"""EpdGetExponentDecimal(double value) -> int"""
    return _repycudd.EpdGetExponentDecimal(value)

def IsInfDouble(value):
    r"""IsInfDouble(double value) -> bool"""
    return _repycudd.IsInfDouble(value)

def IsNanDouble(value):
    r"""IsNanDouble(double value) -> bool"""
    return _repycudd.IsNanDouble(value)

def IsNanOrInfDouble(value):
    r"""IsNanOrInfDouble(double value) -> bool"""
    return _repycudd.IsNanOrInfDouble(value)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class DdManager(object):
    r"""Proxy of C++ DdManager class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    __doc__ = "This class wraps around the DdManager. The methods defined by this class provide themselves as the DdManager option (if needed)."


    def __init__(self, *args):
        r"""__init__(DdManager self, unsigned int numVars=0, unsigned int numVarsZ=0, unsigned int numSlots=CUDD_UNIQUE_SLOTS, unsigned int cacheSize=CUDD_CACHE_SLOTS, unsigned long maxMemory=0) -> DdManager"""
        _repycudd.DdManager_swiginit(self, _repycudd.new_DdManager(*args))
    __swig_destroy__ = _repycudd.delete_DdManager

    def KillNode(self, num):
        r"""KillNode(DdManager self, long num)"""
        return _repycudd.DdManager_KillNode(self, num)

    def IsPsVar(self, index):
        r"""IsPsVar(DdManager self, int index) -> int"""
        return _repycudd.DdManager_IsPsVar(self, index)

    def IsNsVar(self, index):
        r"""IsNsVar(DdManager self, int index) -> int"""
        return _repycudd.DdManager_IsNsVar(self, index)

    def SetPsVar(self, index):
        r"""SetPsVar(DdManager self, int index) -> int"""
        return _repycudd.DdManager_SetPsVar(self, index)

    def SetNsVar(self, index):
        r"""SetNsVar(DdManager self, int index) -> int"""
        return _repycudd.DdManager_SetNsVar(self, index)

    def SetPairIndex(self, index, pairIndex):
        r"""SetPairIndex(DdManager self, int index, int pairIndex) -> int"""
        return _repycudd.DdManager_SetPairIndex(self, index, pairIndex)

    def ReadPairIndex(self, index):
        r"""ReadPairIndex(DdManager self, int index) -> int"""
        return _repycudd.DdManager_ReadPairIndex(self, index)

    def SetVarToBeGrouped(self, index):
        r"""SetVarToBeGrouped(DdManager self, int index) -> int"""
        return _repycudd.DdManager_SetVarToBeGrouped(self, index)

    def SetVarHardGroup(self, index):
        r"""SetVarHardGroup(DdManager self, int index) -> int"""
        return _repycudd.DdManager_SetVarHardGroup(self, index)

    def ResetVarToBeGrouped(self, index):
        r"""ResetVarToBeGrouped(DdManager self, int index) -> int"""
        return _repycudd.DdManager_ResetVarToBeGrouped(self, index)

    def IsVarToBeGrouped(self, index):
        r"""IsVarToBeGrouped(DdManager self, int index) -> int"""
        return _repycudd.DdManager_IsVarToBeGrouped(self, index)

    def IsVarHardGroup(self, index):
        r"""IsVarHardGroup(DdManager self, int index) -> int"""
        return _repycudd.DdManager_IsVarHardGroup(self, index)

    def SetVarToBeUngrouped(self, index):
        r"""SetVarToBeUngrouped(DdManager self, int index) -> int"""
        return _repycudd.DdManager_SetVarToBeUngrouped(self, index)

    def IsVarToBeUngrouped(self, index):
        r"""IsVarToBeUngrouped(DdManager self, int index) -> int"""
        return _repycudd.DdManager_IsVarToBeUngrouped(self, index)

    def SetPiVar(self, index):
        r"""SetPiVar(DdManager self, int index) -> int"""
        return _repycudd.DdManager_SetPiVar(self, index)

    def IsPiVar(self, index):
        r"""IsPiVar(DdManager self, int index) -> int"""
        return _repycudd.DdManager_IsPiVar(self, index)

    def BindVar(self, index):
        r"""BindVar(DdManager self, int index) -> int"""
        return _repycudd.DdManager_BindVar(self, index)

    def UnbindVar(self, index):
        r"""UnbindVar(DdManager self, int index) -> int"""
        return _repycudd.DdManager_UnbindVar(self, index)

    def VarIsBound(self, index):
        r"""VarIsBound(DdManager self, int index) -> int"""
        return _repycudd.DdManager_VarIsBound(self, index)

    def ReadMaxGrowthAlternate(self):
        r"""ReadMaxGrowthAlternate(DdManager self) -> double"""
        return _repycudd.DdManager_ReadMaxGrowthAlternate(self)

    def SetMaxGrowthAlternate(self, mg):
        r"""SetMaxGrowthAlternate(DdManager self, double mg)"""
        return _repycudd.DdManager_SetMaxGrowthAlternate(self, mg)

    def ReadReorderingCycle(self):
        r"""ReadReorderingCycle(DdManager self) -> int"""
        return _repycudd.DdManager_ReadReorderingCycle(self)

    def SetReorderingCycle(self, cycle):
        r"""SetReorderingCycle(DdManager self, int cycle)"""
        return _repycudd.DdManager_SetReorderingCycle(self, cycle)

    def PrintCover(self, l, u):
        r"""PrintCover(DdManager self, DdNode l, DdNode u) -> int"""
        return _repycudd.DdManager_PrintCover(self, l, u)

    def Prime(self, p):
        r"""Prime(DdManager self, unsigned int p) -> unsigned int"""
        return _repycudd.DdManager_Prime(self, p)

    def __len__(self):
        r"""__len__(DdManager self) -> int"""
        return _repycudd.DdManager___len__(self)

    def __getitem__(self, i):
        r"""__getitem__(DdManager self, int i) -> DdNode"""
        return _repycudd.DdManager___getitem__(self, i)

    def __eq__(self, other):
        r"""__eq__(DdManager self, DdManager other) -> bool"""
        return _repycudd.DdManager___eq__(self, other)

    def __ne__(self, other):
        r"""__ne__(DdManager self, DdManager other) -> bool"""
        return _repycudd.DdManager___ne__(self, other)

    def addNewVar(self):
        r"""addNewVar(DdManager self) -> DdNode"""
        return _repycudd.DdManager_addNewVar(self)

    def addNewVarAtLevel(self, level):
        r"""addNewVarAtLevel(DdManager self, int level) -> DdNode"""
        return _repycudd.DdManager_addNewVarAtLevel(self, level)

    def NewVar(self):
        r"""NewVar(DdManager self) -> DdNode"""
        return _repycudd.DdManager_NewVar(self)

    def NewVarAtLevel(self, level):
        r"""NewVarAtLevel(DdManager self, int level) -> DdNode"""
        return _repycudd.DdManager_NewVarAtLevel(self, level)

    def addIthVar(self, i):
        r"""addIthVar(DdManager self, int i) -> DdNode"""
        return _repycudd.DdManager_addIthVar(self, i)

    def IthVar(self, i):
        r"""IthVar(DdManager self, int i) -> DdNode"""
        return _repycudd.DdManager_IthVar(self, i)

    def zddIthVar(self, i):
        r"""zddIthVar(DdManager self, int i) -> DdNode"""
        return _repycudd.DdManager_zddIthVar(self, i)

    def zddVarsFromBddVars(self, multiplicity):
        r"""zddVarsFromBddVars(DdManager self, int multiplicity) -> int"""
        return _repycudd.DdManager_zddVarsFromBddVars(self, multiplicity)

    def addConst(self, c):
        r"""addConst(DdManager self, CUDD_VALUE_TYPE c) -> DdNode"""
        return _repycudd.DdManager_addConst(self, c)

    def AutodynEnable(self, method):
        r"""AutodynEnable(DdManager self, int method)"""
        return _repycudd.DdManager_AutodynEnable(self, method)

    def AutodynDisable(self):
        r"""AutodynDisable(DdManager self)"""
        return _repycudd.DdManager_AutodynDisable(self)

    def ReorderingStatus(self):
        r"""ReorderingStatus(DdManager self) -> int"""
        return _repycudd.DdManager_ReorderingStatus(self)

    def AutodynEnableZdd(self, method):
        r"""AutodynEnableZdd(DdManager self, int method)"""
        return _repycudd.DdManager_AutodynEnableZdd(self, method)

    def AutodynDisableZdd(self):
        r"""AutodynDisableZdd(DdManager self)"""
        return _repycudd.DdManager_AutodynDisableZdd(self)

    def ReorderingStatusZdd(self):
        r"""ReorderingStatusZdd(DdManager self) -> int"""
        return _repycudd.DdManager_ReorderingStatusZdd(self)

    def zddRealignmentEnabled(self):
        r"""zddRealignmentEnabled(DdManager self) -> int"""
        return _repycudd.DdManager_zddRealignmentEnabled(self)

    def zddRealignEnable(self):
        r"""zddRealignEnable(DdManager self)"""
        return _repycudd.DdManager_zddRealignEnable(self)

    def zddRealignDisable(self):
        r"""zddRealignDisable(DdManager self)"""
        return _repycudd.DdManager_zddRealignDisable(self)

    def RealignmentEnabled(self):
        r"""RealignmentEnabled(DdManager self) -> int"""
        return _repycudd.DdManager_RealignmentEnabled(self)

    def RealignEnable(self):
        r"""RealignEnable(DdManager self)"""
        return _repycudd.DdManager_RealignEnable(self)

    def RealignDisable(self):
        r"""RealignDisable(DdManager self)"""
        return _repycudd.DdManager_RealignDisable(self)

    def ReadOne(self):
        r"""ReadOne(DdManager self) -> DdNode"""
        return _repycudd.DdManager_ReadOne(self)

    def ReadZddOne(self, i):
        r"""ReadZddOne(DdManager self, int i) -> DdNode"""
        return _repycudd.DdManager_ReadZddOne(self, i)

    def ReadZero(self):
        r"""ReadZero(DdManager self) -> DdNode"""
        return _repycudd.DdManager_ReadZero(self)

    def ReadLogicZero(self):
        r"""ReadLogicZero(DdManager self) -> DdNode"""
        return _repycudd.DdManager_ReadLogicZero(self)

    def ReadPlusInfinity(self):
        r"""ReadPlusInfinity(DdManager self) -> DdNode"""
        return _repycudd.DdManager_ReadPlusInfinity(self)

    def ReadMinusInfinity(self):
        r"""ReadMinusInfinity(DdManager self) -> DdNode"""
        return _repycudd.DdManager_ReadMinusInfinity(self)

    def ReadBackground(self):
        r"""ReadBackground(DdManager self) -> DdNode"""
        return _repycudd.DdManager_ReadBackground(self)

    def ReadCacheSlots(self):
        r"""ReadCacheSlots(DdManager self) -> unsigned int"""
        return _repycudd.DdManager_ReadCacheSlots(self)

    def ReadCacheUsedSlots(self):
        r"""ReadCacheUsedSlots(DdManager self) -> double"""
        return _repycudd.DdManager_ReadCacheUsedSlots(self)

    def ReadCacheLookUps(self):
        r"""ReadCacheLookUps(DdManager self) -> double"""
        return _repycudd.DdManager_ReadCacheLookUps(self)

    def ReadCacheHits(self):
        r"""ReadCacheHits(DdManager self) -> double"""
        return _repycudd.DdManager_ReadCacheHits(self)

    def ReadRecursiveCalls(self):
        r"""ReadRecursiveCalls(DdManager self) -> double"""
        return _repycudd.DdManager_ReadRecursiveCalls(self)

    def ReadMinHit(self):
        r"""ReadMinHit(DdManager self) -> unsigned int"""
        return _repycudd.DdManager_ReadMinHit(self)

    def SetMinHit(self, hr):
        r"""SetMinHit(DdManager self, unsigned int hr)"""
        return _repycudd.DdManager_SetMinHit(self, hr)

    def ReadLooseUpTo(self):
        r"""ReadLooseUpTo(DdManager self) -> unsigned int"""
        return _repycudd.DdManager_ReadLooseUpTo(self)

    def SetLooseUpTo(self, lut):
        r"""SetLooseUpTo(DdManager self, unsigned int lut)"""
        return _repycudd.DdManager_SetLooseUpTo(self, lut)

    def ReadMaxCache(self):
        r"""ReadMaxCache(DdManager self) -> unsigned int"""
        return _repycudd.DdManager_ReadMaxCache(self)

    def ReadMaxCacheHard(self):
        r"""ReadMaxCacheHard(DdManager self) -> unsigned int"""
        return _repycudd.DdManager_ReadMaxCacheHard(self)

    def SetMaxCacheHard(self, mc):
        r"""SetMaxCacheHard(DdManager self, unsigned int mc)"""
        return _repycudd.DdManager_SetMaxCacheHard(self, mc)

    def ReadSize(self):
        r"""ReadSize(DdManager self) -> int"""
        return _repycudd.DdManager_ReadSize(self)

    def ReadZddSize(self):
        r"""ReadZddSize(DdManager self) -> int"""
        return _repycudd.DdManager_ReadZddSize(self)

    def ReadSlots(self):
        r"""ReadSlots(DdManager self) -> unsigned int"""
        return _repycudd.DdManager_ReadSlots(self)

    def ReadUsedSlots(self):
        r"""ReadUsedSlots(DdManager self) -> double"""
        return _repycudd.DdManager_ReadUsedSlots(self)

    def ExpectedUsedSlots(self):
        r"""ExpectedUsedSlots(DdManager self) -> double"""
        return _repycudd.DdManager_ExpectedUsedSlots(self)

    def ReadKeys(self):
        r"""ReadKeys(DdManager self) -> unsigned int"""
        return _repycudd.DdManager_ReadKeys(self)

    def ReadDead(self):
        r"""ReadDead(DdManager self) -> unsigned int"""
        return _repycudd.DdManager_ReadDead(self)

    def ReadMinDead(self):
        r"""ReadMinDead(DdManager self) -> unsigned int"""
        return _repycudd.DdManager_ReadMinDead(self)

    def ReadReorderings(self):
        r"""ReadReorderings(DdManager self) -> int"""
        return _repycudd.DdManager_ReadReorderings(self)

    def ReadReorderingTime(self):
        r"""ReadReorderingTime(DdManager self) -> long"""
        return _repycudd.DdManager_ReadReorderingTime(self)

    def ReadGarbageCollections(self):
        r"""ReadGarbageCollections(DdManager self) -> int"""
        return _repycudd.DdManager_ReadGarbageCollections(self)

    def ReadGarbageCollectionTime(self):
        r"""ReadGarbageCollectionTime(DdManager self) -> long"""
        return _repycudd.DdManager_ReadGarbageCollectionTime(self)

    def GarbageCollect(self, clearCache):
        r"""GarbageCollect(DdManager self, int clearCache) -> int"""
        return _repycudd.DdManager_GarbageCollect(self, clearCache)

    def ReadNodesFreed(self):
        r"""ReadNodesFreed(DdManager self) -> double"""
        return _repycudd.DdManager_ReadNodesFreed(self)

    def ReadNodesDropped(self):
        r"""ReadNodesDropped(DdManager self) -> double"""
        return _repycudd.DdManager_ReadNodesDropped(self)

    def ReadUniqueLookUps(self):
        r"""ReadUniqueLookUps(DdManager self) -> double"""
        return _repycudd.DdManager_ReadUniqueLookUps(self)

    def ReadUniqueLinks(self):
        r"""ReadUniqueLinks(DdManager self) -> double"""
        return _repycudd.DdManager_ReadUniqueLinks(self)

    def ReadSiftMaxVar(self):
        r"""ReadSiftMaxVar(DdManager self) -> int"""
        return _repycudd.DdManager_ReadSiftMaxVar(self)

    def SetSiftMaxVar(self, smv):
        r"""SetSiftMaxVar(DdManager self, int smv)"""
        return _repycudd.DdManager_SetSiftMaxVar(self, smv)

    def ReadSiftMaxSwap(self):
        r"""ReadSiftMaxSwap(DdManager self) -> int"""
        return _repycudd.DdManager_ReadSiftMaxSwap(self)

    def SetSiftMaxSwap(self, sms):
        r"""SetSiftMaxSwap(DdManager self, int sms)"""
        return _repycudd.DdManager_SetSiftMaxSwap(self, sms)

    def ReadMaxGrowth(self):
        r"""ReadMaxGrowth(DdManager self) -> double"""
        return _repycudd.DdManager_ReadMaxGrowth(self)

    def SetMaxGrowth(self, mg):
        r"""SetMaxGrowth(DdManager self, double mg)"""
        return _repycudd.DdManager_SetMaxGrowth(self, mg)

    def ReadTree(self):
        r"""ReadTree(DdManager self) -> MtrNode"""
        return _repycudd.DdManager_ReadTree(self)

    def SetTree(self, tree):
        r"""SetTree(DdManager self, MtrNode tree)"""
        return _repycudd.DdManager_SetTree(self, tree)

    def FreeTree(self):
        r"""FreeTree(DdManager self)"""
        return _repycudd.DdManager_FreeTree(self)

    def ReadZddTree(self):
        r"""ReadZddTree(DdManager self) -> MtrNode"""
        return _repycudd.DdManager_ReadZddTree(self)

    def SetZddTree(self, tree):
        r"""SetZddTree(DdManager self, MtrNode tree)"""
        return _repycudd.DdManager_SetZddTree(self, tree)

    def FreeZddTree(self):
        r"""FreeZddTree(DdManager self)"""
        return _repycudd.DdManager_FreeZddTree(self)

    def ReadPerm(self, i):
        r"""ReadPerm(DdManager self, int i) -> int"""
        return _repycudd.DdManager_ReadPerm(self, i)

    def ReadPermZdd(self, i):
        r"""ReadPermZdd(DdManager self, int i) -> int"""
        return _repycudd.DdManager_ReadPermZdd(self, i)

    def ReadInvPerm(self, i):
        r"""ReadInvPerm(DdManager self, int i) -> int"""
        return _repycudd.DdManager_ReadInvPerm(self, i)

    def ReadInvPermZdd(self, i):
        r"""ReadInvPermZdd(DdManager self, int i) -> int"""
        return _repycudd.DdManager_ReadInvPermZdd(self, i)

    def ReadVars(self, i):
        r"""ReadVars(DdManager self, int i) -> DdNode"""
        return _repycudd.DdManager_ReadVars(self, i)

    def ReadEpsilon(self):
        r"""ReadEpsilon(DdManager self) -> CUDD_VALUE_TYPE"""
        return _repycudd.DdManager_ReadEpsilon(self)

    def SetEpsilon(self, ep):
        r"""SetEpsilon(DdManager self, CUDD_VALUE_TYPE ep)"""
        return _repycudd.DdManager_SetEpsilon(self, ep)

    def ReadGroupcheck(self):
        r"""ReadGroupcheck(DdManager self) -> Cudd_AggregationType"""
        return _repycudd.DdManager_ReadGroupcheck(self)

    def SetGroupcheck(self, gc):
        r"""SetGroupcheck(DdManager self, Cudd_AggregationType gc)"""
        return _repycudd.DdManager_SetGroupcheck(self, gc)

    def GarbageCollectionEnabled(self):
        r"""GarbageCollectionEnabled(DdManager self) -> int"""
        return _repycudd.DdManager_GarbageCollectionEnabled(self)

    def EnableGarbageCollection(self):
        r"""EnableGarbageCollection(DdManager self)"""
        return _repycudd.DdManager_EnableGarbageCollection(self)

    def DisableGarbageCollection(self):
        r"""DisableGarbageCollection(DdManager self)"""
        return _repycudd.DdManager_DisableGarbageCollection(self)

    def DeadAreCounted(self):
        r"""DeadAreCounted(DdManager self) -> int"""
        return _repycudd.DdManager_DeadAreCounted(self)

    def TurnOnCountDead(self):
        r"""TurnOnCountDead(DdManager self)"""
        return _repycudd.DdManager_TurnOnCountDead(self)

    def TurnOffCountDead(self):
        r"""TurnOffCountDead(DdManager self)"""
        return _repycudd.DdManager_TurnOffCountDead(self)

    def ReadRecomb(self):
        r"""ReadRecomb(DdManager self) -> int"""
        return _repycudd.DdManager_ReadRecomb(self)

    def SetRecomb(self, recomb):
        r"""SetRecomb(DdManager self, int recomb)"""
        return _repycudd.DdManager_SetRecomb(self, recomb)

    def ReadSymmviolation(self):
        r"""ReadSymmviolation(DdManager self) -> int"""
        return _repycudd.DdManager_ReadSymmviolation(self)

    def SetSymmviolation(self, symmviolation):
        r"""SetSymmviolation(DdManager self, int symmviolation)"""
        return _repycudd.DdManager_SetSymmviolation(self, symmviolation)

    def ReadArcviolation(self):
        r"""ReadArcviolation(DdManager self) -> int"""
        return _repycudd.DdManager_ReadArcviolation(self)

    def SetArcviolation(self, arcviolation):
        r"""SetArcviolation(DdManager self, int arcviolation)"""
        return _repycudd.DdManager_SetArcviolation(self, arcviolation)

    def ReadPopulationSize(self):
        r"""ReadPopulationSize(DdManager self) -> int"""
        return _repycudd.DdManager_ReadPopulationSize(self)

    def SetPopulationSize(self, populationSize):
        r"""SetPopulationSize(DdManager self, int populationSize)"""
        return _repycudd.DdManager_SetPopulationSize(self, populationSize)

    def ReadNumberXovers(self):
        r"""ReadNumberXovers(DdManager self) -> int"""
        return _repycudd.DdManager_ReadNumberXovers(self)

    def SetNumberXovers(self, numberXovers):
        r"""SetNumberXovers(DdManager self, int numberXovers)"""
        return _repycudd.DdManager_SetNumberXovers(self, numberXovers)

    def ReadMemoryInUse(self):
        r"""ReadMemoryInUse(DdManager self) -> long"""
        return _repycudd.DdManager_ReadMemoryInUse(self)

    def PrintInfo(self, fp):
        r"""PrintInfo(DdManager self, FILE * fp) -> int"""
        return _repycudd.DdManager_PrintInfo(self, fp)

    def ReadPeakNodeCount(self):
        r"""ReadPeakNodeCount(DdManager self) -> long"""
        return _repycudd.DdManager_ReadPeakNodeCount(self)

    def ReadPeakLiveNodeCount(self):
        r"""ReadPeakLiveNodeCount(DdManager self) -> int"""
        return _repycudd.DdManager_ReadPeakLiveNodeCount(self)

    def ReadNodeCount(self):
        r"""ReadNodeCount(DdManager self) -> long"""
        return _repycudd.DdManager_ReadNodeCount(self)

    def zddReadNodeCount(self):
        r"""zddReadNodeCount(DdManager self) -> long"""
        return _repycudd.DdManager_zddReadNodeCount(self)

    def EnableReorderingReporting(self):
        r"""EnableReorderingReporting(DdManager self) -> int"""
        return _repycudd.DdManager_EnableReorderingReporting(self)

    def DisableReorderingReporting(self):
        r"""DisableReorderingReporting(DdManager self) -> int"""
        return _repycudd.DdManager_DisableReorderingReporting(self)

    def ReorderingReporting(self):
        r"""ReorderingReporting(DdManager self) -> int"""
        return _repycudd.DdManager_ReorderingReporting(self)

    def ReadErrorCode(self):
        r"""ReadErrorCode(DdManager self) -> Cudd_ErrorType"""
        return _repycudd.DdManager_ReadErrorCode(self)

    def ClearErrorCode(self):
        r"""ClearErrorCode(DdManager self)"""
        return _repycudd.DdManager_ClearErrorCode(self)

    def ReadStdout(self):
        r"""ReadStdout(DdManager self) -> FILE *"""
        return _repycudd.DdManager_ReadStdout(self)

    def SetStdout(self, fp):
        r"""SetStdout(DdManager self, FILE * fp)"""
        return _repycudd.DdManager_SetStdout(self, fp)

    def ReadStderr(self):
        r"""ReadStderr(DdManager self) -> FILE *"""
        return _repycudd.DdManager_ReadStderr(self)

    def SetStderr(self, fp):
        r"""SetStderr(DdManager self, FILE * fp)"""
        return _repycudd.DdManager_SetStderr(self, fp)

    def ReadNextReordering(self):
        r"""ReadNextReordering(DdManager self) -> unsigned int"""
        return _repycudd.DdManager_ReadNextReordering(self)

    def ReadSwapSteps(self):
        r"""ReadSwapSteps(DdManager self) -> double"""
        return _repycudd.DdManager_ReadSwapSteps(self)

    def ReadMaxLive(self):
        r"""ReadMaxLive(DdManager self) -> unsigned int"""
        return _repycudd.DdManager_ReadMaxLive(self)

    def SetMaxLive(self, maxLive):
        r"""SetMaxLive(DdManager self, unsigned int maxLive)"""
        return _repycudd.DdManager_SetMaxLive(self, maxLive)

    def ReadMaxMemory(self):
        r"""ReadMaxMemory(DdManager self) -> long"""
        return _repycudd.DdManager_ReadMaxMemory(self)

    def SetMaxMemory(self, maxMemory):
        r"""SetMaxMemory(DdManager self, long maxMemory)"""
        return _repycudd.DdManager_SetMaxMemory(self, maxMemory)

    def SetNextReordering(self, next):
        r"""SetNextReordering(DdManager self, unsigned int next)"""
        return _repycudd.DdManager_SetNextReordering(self, next)

    def DebugCheck(self):
        r"""DebugCheck(DdManager self) -> int"""
        return _repycudd.DdManager_DebugCheck(self)

    def CheckKeys(self):
        r"""CheckKeys(DdManager self) -> int"""
        return _repycudd.DdManager_CheckKeys(self)

    def MakeTreeNode(self, low, size, type):
        r"""MakeTreeNode(DdManager self, unsigned int low, unsigned int size, unsigned int type) -> MtrNode"""
        return _repycudd.DdManager_MakeTreeNode(self, low, size, type)

    def PrintLinear(self):
        r"""PrintLinear(DdManager self) -> int"""
        return _repycudd.DdManager_PrintLinear(self)

    def ReadLinear(self, x, y):
        r"""ReadLinear(DdManager self, int x, int y) -> int"""
        return _repycudd.DdManager_ReadLinear(self, x, y)

    def CheckZeroRef(self):
        r"""CheckZeroRef(DdManager self) -> int"""
        return _repycudd.DdManager_CheckZeroRef(self)

    def ReduceHeap(self, heuristic, minsize):
        r"""ReduceHeap(DdManager self, int heuristic, int minsize) -> int"""
        return _repycudd.DdManager_ReduceHeap(self, heuristic, minsize)

    def ShuffleHeap(self, permutation):
        r"""ShuffleHeap(DdManager self, IntArray permutation) -> int"""
        return _repycudd.DdManager_ShuffleHeap(self, permutation)

    def SymmProfile(self, lower, upper):
        r"""SymmProfile(DdManager self, int lower, int upper)"""
        return _repycudd.DdManager_SymmProfile(self, lower, upper)

    def IndicesToCube(self, array, n):
        r"""IndicesToCube(DdManager self, IntArray array, int n) -> DdNode"""
        return _repycudd.DdManager_IndicesToCube(self, array, n)

    def AverageDistance(self):
        r"""AverageDistance(DdManager self) -> double"""
        return _repycudd.DdManager_AverageDistance(self)

    def MakeZddTreeNode(self, low, size, type):
        r"""MakeZddTreeNode(DdManager self, unsigned int low, unsigned int size, unsigned int type) -> MtrNode"""
        return _repycudd.DdManager_MakeZddTreeNode(self, low, size, type)

    def zddPrintSubtable(self):
        r"""zddPrintSubtable(DdManager self)"""
        return _repycudd.DdManager_zddPrintSubtable(self)

    def zddReduceHeap(self, heuristic, minsize):
        r"""zddReduceHeap(DdManager self, int heuristic, int minsize) -> int"""
        return _repycudd.DdManager_zddReduceHeap(self, heuristic, minsize)

    def zddShuffleHeap(self, permutation):
        r"""zddShuffleHeap(DdManager self, IntArray permutation) -> int"""
        return _repycudd.DdManager_zddShuffleHeap(self, permutation)

    def zddSymmProfile(self, lower, upper):
        r"""zddSymmProfile(DdManager self, int lower, int upper)"""
        return _repycudd.DdManager_zddSymmProfile(self, lower, upper)

    def BddToAdd(self, B):
        r"""BddToAdd(DdManager self, DdNode B) -> DdNode"""
        return _repycudd.DdManager_BddToAdd(self, B)

    def addBddPattern(self, f):
        r"""addBddPattern(DdManager self, DdNode f) -> DdNode"""
        return _repycudd.DdManager_addBddPattern(self, f)

    def addBddThreshold(self, f, value):
        r"""addBddThreshold(DdManager self, DdNode f, CUDD_VALUE_TYPE value) -> DdNode"""
        return _repycudd.DdManager_addBddThreshold(self, f, value)

    def addBddStrictThreshold(self, f, value):
        r"""addBddStrictThreshold(DdManager self, DdNode f, CUDD_VALUE_TYPE value) -> DdNode"""
        return _repycudd.DdManager_addBddStrictThreshold(self, f, value)

    def addBddInterval(self, f, lower, upper):
        r"""addBddInterval(DdManager self, DdNode f, CUDD_VALUE_TYPE lower, CUDD_VALUE_TYPE upper) -> DdNode"""
        return _repycudd.DdManager_addBddInterval(self, f, lower, upper)

    def addBddIthBit(self, f, bit):
        r"""addBddIthBit(DdManager self, DdNode f, int bit) -> DdNode"""
        return _repycudd.DdManager_addBddIthBit(self, f, bit)

    def zddPortFromBdd(self, B):
        r"""zddPortFromBdd(DdManager self, DdNode B) -> DdNode"""
        return _repycudd.DdManager_zddPortFromBdd(self, B)

    def zddPortToBdd(self, f):
        r"""zddPortToBdd(DdManager self, DdNode f) -> DdNode"""
        return _repycudd.DdManager_zddPortToBdd(self, f)

    def MakeBddFromZddCover(self, node):
        r"""MakeBddFromZddCover(DdManager self, DdNode node) -> DdNode"""
        return _repycudd.DdManager_MakeBddFromZddCover(self, node)

    def PrintVersion(self, fp):
        r"""PrintVersion(DdManager self, FILE * fp)"""
        return _repycudd.DdManager_PrintVersion(self, fp)

    def Random(self):
        r"""Random(DdManager self) -> long"""
        return _repycudd.DdManager_Random(self)

    def Srandom(self, seed):
        r"""Srandom(DdManager self, long seed)"""
        return _repycudd.DdManager_Srandom(self, seed)

    def OutOfMem(self, size):
        r"""OutOfMem(DdManager self, long size)"""
        return _repycudd.DdManager_OutOfMem(self, size)

    def Transfer(self, ddDestination, f):
        r"""Transfer(DdManager self, DdManager ddDestination, DdNode f) -> DdNode"""
        return _repycudd.DdManager_Transfer(self, ddDestination, f)

    def CubeArrayToBdd(self, y):
        r"""CubeArrayToBdd(DdManager self, IntArray y) -> DdNode"""
        return _repycudd.DdManager_CubeArrayToBdd(self, y)

    def SetVarMap(self, x, y, n):
        r"""SetVarMap(DdManager self, DdArray x, DdArray y, int n) -> int"""
        return _repycudd.DdManager_SetVarMap(self, x, y, n)

    def ComputeCube(self, vars, phase, n):
        r"""ComputeCube(DdManager self, DdArray vars, IntArray phase, int n) -> DdNode"""
        return _repycudd.DdManager_ComputeCube(self, vars, phase, n)

    def zddDumpDot(self, n, f, inames, onames, fp):
        r"""zddDumpDot(DdManager self, int n, DdArray f, char ** inames, char ** onames, FILE * fp) -> int"""
        return _repycudd.DdManager_zddDumpDot(self, n, f, inames, onames, fp)

    def DumpBlifBody(self, n, f, inames, onames, fp, mv):
        r"""DumpBlifBody(DdManager self, int n, DdArray f, char ** inames, char ** onames, FILE * fp, int mv) -> int"""
        return _repycudd.DdManager_DumpBlifBody(self, n, f, inames, onames, fp, mv)

    def DumpDaVinci(self, n, f, inames, onames, fp):
        r"""DumpDaVinci(DdManager self, int n, DdArray f, char ** inames, char ** onames, FILE * fp) -> int"""
        return _repycudd.DdManager_DumpDaVinci(self, n, f, inames, onames, fp)

    def DumpDDcal(self, n, f, inames, onames, fp):
        r"""DumpDDcal(DdManager self, int n, DdArray f, char ** inames, char ** onames, FILE * fp) -> int"""
        return _repycudd.DdManager_DumpDDcal(self, n, f, inames, onames, fp)

    def DumpFactoredForm(self, n, f, inames, onames, fp):
        r"""DumpFactoredForm(DdManager self, int n, DdArray f, char ** inames, char ** onames, FILE * fp) -> int"""
        return _repycudd.DdManager_DumpFactoredForm(self, n, f, inames, onames, fp)

    def ArrayLoad(self, rootmatchmode, rootmatchnames, varmatchmode, varmatchnames, varmatchauxids, varcomposeids, mode, filename, fp, pproots):
        r"""ArrayLoad(DdManager self, int rootmatchmode, char ** rootmatchnames, int varmatchmode, char ** varmatchnames, IntArray varmatchauxids, IntArray varcomposeids, int mode, char * filename, FILE * fp, DdArray pproots) -> int"""
        return _repycudd.DdManager_ArrayLoad(self, rootmatchmode, rootmatchnames, varmatchmode, varmatchnames, varmatchauxids, varcomposeids, mode, filename, fp, pproots)

    def ArrayStore(self, ddname, roots, rootnames, varnames, auxids, mode, varinfo, filename, fp):
        r"""ArrayStore(DdManager self, char * ddname, DdArray roots, char ** rootnames, char ** varnames, IntArray auxids, int mode, int varinfo, char * filename, FILE * fp) -> int"""
        return _repycudd.DdManager_ArrayStore(self, ddname, roots, rootnames, varnames, auxids, mode, varinfo, filename, fp)

    def BddLoad(self, varmatchmode, varmatchnames, varmatchauxids, varcomposeids, mode, filename, fp):
        r"""BddLoad(DdManager self, int varmatchmode, char ** varmatchnames, IntArray varmatchauxids, IntArray varcomposeids, int mode, char * filename, FILE * fp) -> DdNode"""
        return _repycudd.DdManager_BddLoad(self, varmatchmode, varmatchnames, varmatchauxids, varcomposeids, mode, filename, fp)

    def Bin2Text(self, filein, fileout):
        r"""Bin2Text(DdManager self, char * filein, char * fileout) -> int"""
        return _repycudd.DdManager_Bin2Text(self, filein, fileout)

    def DisplayBinary(self, filein, fileout):
        r"""DisplayBinary(DdManager self, char * filein, char * fileout) -> int"""
        return _repycudd.DdManager_DisplayBinary(self, filein, fileout)

    def Text2Bin(self, filein, fileout):
        r"""Text2Bin(DdManager self, char * filein, char * fileout) -> int"""
        return _repycudd.DdManager_Text2Bin(self, filein, fileout)

    def VectorSupportSize(self, F, n):
        r"""VectorSupportSize(DdManager self, DdArray F, int n) -> int"""
        return _repycudd.DdManager_VectorSupportSize(self, F, n)

    def ClassifySupport(self, f, g, common, onlyF, onlyG):
        r"""ClassifySupport(DdManager self, DdNode f, DdNode g, DdArray common, DdArray onlyF, DdArray onlyG) -> int"""
        return _repycudd.DdManager_ClassifySupport(self, f, g, common, onlyF, onlyG)

    def Xgty(self, N, z, x, y):
        r"""Xgty(DdManager self, int N, DdArray z, DdArray x, DdArray y) -> DdNode"""
        return _repycudd.DdManager_Xgty(self, N, z, x, y)

    def Xeqy(self, N, x, y):
        r"""Xeqy(DdManager self, int N, DdArray x, DdArray y) -> DdNode"""
        return _repycudd.DdManager_Xeqy(self, N, x, y)

    def Dxygtdxz(self, N, x, y, z):
        r"""Dxygtdxz(DdManager self, int N, DdArray x, DdArray y, DdArray z) -> DdNode"""
        return _repycudd.DdManager_Dxygtdxz(self, N, x, y, z)

    def Dxygtdyz(self, N, x, y, z):
        r"""Dxygtdyz(DdManager self, int N, DdArray x, DdArray y, DdArray z) -> DdNode"""
        return _repycudd.DdManager_Dxygtdyz(self, N, x, y, z)

    def SharingSize(self, nodeArray, n):
        r"""SharingSize(DdManager self, DdArray nodeArray, int n) -> int"""
        return _repycudd.DdManager_SharingSize(self, nodeArray, n)

    def addPlus(self, f, g):
        r"""addPlus(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addPlus(self, f, g)

    def addTimes(self, f, g):
        r"""addTimes(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addTimes(self, f, g)

    def addThreshold(self, f, g):
        r"""addThreshold(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addThreshold(self, f, g)

    def addSetNZ(self, f, g):
        r"""addSetNZ(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addSetNZ(self, f, g)

    def addDivide(self, f, g):
        r"""addDivide(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addDivide(self, f, g)

    def addMinus(self, f, g):
        r"""addMinus(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addMinus(self, f, g)

    def addMinimum(self, f, g):
        r"""addMinimum(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addMinimum(self, f, g)

    def addMaximum(self, f, g):
        r"""addMaximum(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addMaximum(self, f, g)

    def addOneZeroMaximum(self, f, g):
        r"""addOneZeroMaximum(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addOneZeroMaximum(self, f, g)

    def addDiff(self, f, g):
        r"""addDiff(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addDiff(self, f, g)

    def addAgreement(self, f, g):
        r"""addAgreement(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addAgreement(self, f, g)

    def addOr(self, f, g):
        r"""addOr(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addOr(self, f, g)

    def addNand(self, f, g):
        r"""addNand(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addNand(self, f, g)

    def addNor(self, f, g):
        r"""addNor(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addNor(self, f, g)

    def addXor(self, f, g):
        r"""addXor(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addXor(self, f, g)

    def addXnor(self, f, g):
        r"""addXnor(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _repycudd.DdManager_addXnor(self, f, g)

    def addWalsh(self, x, y, n):
        r"""addWalsh(DdManager self, DdArray x, DdArray y, int n) -> DdNode"""
        return _repycudd.DdManager_addWalsh(self, x, y, n)

    def addHamming(self, xVars, yVars, nVars):
        r"""addHamming(DdManager self, DdArray xVars, DdArray yVars, int nVars) -> DdNode"""
        return _repycudd.DdManager_addHamming(self, xVars, yVars, nVars)

    def addComputeCube(self, vars, phase, n):
        r"""addComputeCube(DdManager self, DdArray vars, IntArray phase, int n) -> DdNode"""
        return _repycudd.DdManager_addComputeCube(self, vars, phase, n)

    def addResidue(self, n, m, options, top):
        r"""addResidue(DdManager self, int n, int m, int options, int top) -> DdNode"""
        return _repycudd.DdManager_addResidue(self, n, m, options, top)

    def addXeqy(self, N, x, y):
        r"""addXeqy(DdManager self, int N, DdArray x, DdArray y) -> DdNode"""
        return _repycudd.DdManager_addXeqy(self, N, x, y)

    def ApaNumberOfDigits(self, binaryDigits):
        r"""ApaNumberOfDigits(DdManager self, int binaryDigits) -> int"""
        return _repycudd.DdManager_ApaNumberOfDigits(self, binaryDigits)

    def NewApaNumber(self, digits):
        r"""NewApaNumber(DdManager self, int digits) -> DdApaNumber"""
        return _repycudd.DdManager_NewApaNumber(self, digits)

    def ApaCopy(self, digits, source, dest):
        r"""ApaCopy(DdManager self, int digits, DdApaNumber source, DdApaNumber dest)"""
        return _repycudd.DdManager_ApaCopy(self, digits, source, dest)

    def ApaAdd(self, digits, a, b, sum):
        r"""ApaAdd(DdManager self, int digits, DdApaNumber a, DdApaNumber b, DdApaNumber sum) -> DdApaDigit"""
        return _repycudd.DdManager_ApaAdd(self, digits, a, b, sum)

    def ApaSubtract(self, digits, a, b, diff):
        r"""ApaSubtract(DdManager self, int digits, DdApaNumber a, DdApaNumber b, DdApaNumber diff) -> DdApaDigit"""
        return _repycudd.DdManager_ApaSubtract(self, digits, a, b, diff)

    def ApaShortDivision(self, digits, dividend, divisor, quotient):
        r"""ApaShortDivision(DdManager self, int digits, DdApaNumber dividend, DdApaDigit divisor, DdApaNumber quotient) -> DdApaDigit"""
        return _repycudd.DdManager_ApaShortDivision(self, digits, dividend, divisor, quotient)

    def ApaIntDivision(self, digits, dividend, divisor, quotient):
        r"""ApaIntDivision(DdManager self, int digits, DdApaNumber dividend, unsigned int divisor, DdApaNumber quotient) -> unsigned int"""
        return _repycudd.DdManager_ApaIntDivision(self, digits, dividend, divisor, quotient)

    def ApaShiftRight(self, digits, in_, a, b):
        r"""ApaShiftRight(DdManager self, int digits, DdApaDigit in_, DdApaNumber a, DdApaNumber b)"""
        return _repycudd.DdManager_ApaShiftRight(self, digits, in_, a, b)

    def ApaSetToLiteral(self, digits, number, literal):
        r"""ApaSetToLiteral(DdManager self, int digits, DdApaNumber number, DdApaDigit literal)"""
        return _repycudd.DdManager_ApaSetToLiteral(self, digits, number, literal)

    def ApaPowerOfTwo(self, digits, number, power):
        r"""ApaPowerOfTwo(DdManager self, int digits, DdApaNumber number, int power)"""
        return _repycudd.DdManager_ApaPowerOfTwo(self, digits, number, power)

    def ApaCompare(self, digitsFirst, first, digitsSecond, second):
        r"""ApaCompare(DdManager self, int digitsFirst, DdApaNumber first, int digitsSecond, DdApaNumber second) -> int"""
        return _repycudd.DdManager_ApaCompare(self, digitsFirst, first, digitsSecond, second)

    def ApaCompareRatios(self, digitsFirst, firstNum, firstDen, digitsSecond, secondNum, secondDen):
        r"""ApaCompareRatios(DdManager self, int digitsFirst, DdApaNumber firstNum, unsigned int firstDen, int digitsSecond, DdApaNumber secondNum, unsigned int secondDen) -> int"""
        return _repycudd.DdManager_ApaCompareRatios(self, digitsFirst, firstNum, firstDen, digitsSecond, secondNum, secondDen)

    def ApaPrintHex(self, fp, digits, number):
        r"""ApaPrintHex(DdManager self, FILE * fp, int digits, DdApaNumber number) -> int"""
        return _repycudd.DdManager_ApaPrintHex(self, fp, digits, number)

    def ApaPrintDecimal(self, fp, digits, number):
        r"""ApaPrintDecimal(DdManager self, FILE * fp, int digits, DdApaNumber number) -> int"""
        return _repycudd.DdManager_ApaPrintDecimal(self, fp, digits, number)

    def ApaPrintExponential(self, fp, digits, number, precision):
        r"""ApaPrintExponential(DdManager self, FILE * fp, int digits, DdApaNumber number, int precision) -> int"""
        return _repycudd.DdManager_ApaPrintExponential(self, fp, digits, number, precision)

    def One(self):
        r"""One(DdManager self) -> DdNode"""
        return _repycudd.DdManager_One(self)

    def Zero(self):
        r"""Zero(DdManager self) -> DdNode"""
        return _repycudd.DdManager_Zero(self)

    def Sort(self, leftnd, rightnd):
        r"""Sort(DdManager self, DdNode leftnd, DdNode rightnd) -> int"""
        return _repycudd.DdManager_Sort(self, leftnd, rightnd)

    def PrintStdOut(self):
        r"""PrintStdOut(DdManager self) -> int"""
        return _repycudd.DdManager_PrintStdOut(self)

    def StateCube(self, cube, base, offset, scale):
        r"""StateCube(DdManager self, char * cube, int base, int offset, int scale) -> DdNode"""
        return _repycudd.DdManager_StateCube(self, cube, base, offset, scale)

    def AndAbstractLimit(self, this_node, g, cube, limit):
        r"""AndAbstractLimit(DdManager self, DdNode this_node, DdNode g, DdNode cube, unsigned int limit) -> DdNode"""
        return _repycudd.DdManager_AndAbstractLimit(self, this_node, g, cube, limit)

    def AndLimit(self, this_node, g, limit):
        r"""AndLimit(DdManager self, DdNode this_node, DdNode g, unsigned int limit) -> DdNode"""
        return _repycudd.DdManager_AndLimit(self, this_node, g, limit)

    def NPAnd(self, this_node, c):
        r"""NPAnd(DdManager self, DdNode this_node, DdNode c) -> DdNode"""
        return _repycudd.DdManager_NPAnd(self, this_node, c)

    def FindTwoLiteralClauses(self, this_node):
        r"""FindTwoLiteralClauses(DdManager self, DdNode this_node) -> DdTlcInfo"""
        return _repycudd.DdManager_FindTwoLiteralClauses(self, this_node)

    def EpdCountMinterm(self, this_node, nvars, epd):
        r"""EpdCountMinterm(DdManager self, DdNode this_node, int nvars, EpDouble epd) -> int"""
        return _repycudd.DdManager_EpdCountMinterm(self, this_node, nvars, epd)

    def ApproxConjDecomp(self, this_node):
        r"""ApproxConjDecomp(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_ApproxConjDecomp(self, this_node)

    def ApproxDisjDecomp(self, this_node):
        r"""ApproxDisjDecomp(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_ApproxDisjDecomp(self, this_node)

    def IterConjDecomp(self, this_node):
        r"""IterConjDecomp(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_IterConjDecomp(self, this_node)

    def IterDisjDecomp(self, this_node):
        r"""IterDisjDecomp(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_IterDisjDecomp(self, this_node)

    def GenConjDecomp(self, this_node):
        r"""GenConjDecomp(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_GenConjDecomp(self, this_node)

    def GenDisjDecomp(self, this_node):
        r"""GenDisjDecomp(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_GenDisjDecomp(self, this_node)

    def VarConjDecomp(self, this_node):
        r"""VarConjDecomp(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_VarConjDecomp(self, this_node)

    def VarDisjDecomp(self, this_node):
        r"""VarDisjDecomp(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_VarDisjDecomp(self, this_node)

    def ClosestCube(self, this_node, g):
        r"""ClosestCube(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_ClosestCube(self, this_node, g)

    def LeqUnless(self, this_node, g, D):
        r"""LeqUnless(DdManager self, DdNode this_node, DdNode g, DdNode D) -> int"""
        return _repycudd.DdManager_LeqUnless(self, this_node, g, D)

    def MakePrime(self, this_node, f):
        r"""MakePrime(DdManager self, DdNode this_node, DdNode f) -> DdNode"""
        return _repycudd.DdManager_MakePrime(self, this_node, f)

    def SupportIndex(self, this_node):
        r"""SupportIndex(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_SupportIndex(self, this_node)

    def ExistAbstract(self, this_node, cube):
        r"""ExistAbstract(DdManager self, DdNode this_node, DdNode cube) -> DdNode"""
        return _repycudd.DdManager_ExistAbstract(self, this_node, cube)

    def XorExistAbstract(self, this_node, g, cube):
        r"""XorExistAbstract(DdManager self, DdNode this_node, DdNode g, DdNode cube) -> DdNode"""
        return _repycudd.DdManager_XorExistAbstract(self, this_node, g, cube)

    def UnivAbstract(self, this_node, cube):
        r"""UnivAbstract(DdManager self, DdNode this_node, DdNode cube) -> DdNode"""
        return _repycudd.DdManager_UnivAbstract(self, this_node, cube)

    def BooleanDiff(self, this_node, x):
        r"""BooleanDiff(DdManager self, DdNode this_node, int x) -> DdNode"""
        return _repycudd.DdManager_BooleanDiff(self, this_node, x)

    def AndAbstract(self, this_node, g, cube):
        r"""AndAbstract(DdManager self, DdNode this_node, DdNode g, DdNode cube) -> DdNode"""
        return _repycudd.DdManager_AndAbstract(self, this_node, g, cube)

    def VarIsDependent(self, this_node, var):
        r"""VarIsDependent(DdManager self, DdNode this_node, DdNode var) -> int"""
        return _repycudd.DdManager_VarIsDependent(self, this_node, var)

    def Correlation(self, this_node, g):
        r"""Correlation(DdManager self, DdNode this_node, DdNode g) -> double"""
        return _repycudd.DdManager_Correlation(self, this_node, g)

    def CorrelationWeights(self, this_node, g, prob):
        r"""CorrelationWeights(DdManager self, DdNode this_node, DdNode g, DoubleArray prob) -> double"""
        return _repycudd.DdManager_CorrelationWeights(self, this_node, g, prob)

    def Ite(self, this_node, g, h):
        r"""Ite(DdManager self, DdNode this_node, DdNode g, DdNode h) -> DdNode"""
        return _repycudd.DdManager_Ite(self, this_node, g, h)

    def IteConstant(self, this_node, g, h):
        r"""IteConstant(DdManager self, DdNode this_node, DdNode g, DdNode h) -> DdNode"""
        return _repycudd.DdManager_IteConstant(self, this_node, g, h)

    def Intersect(self, this_node, g):
        r"""Intersect(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_Intersect(self, this_node, g)

    def FIntersect(self, this_node, g):
        r"""FIntersect(DdManager self, DdNode this_node, DdNode g) -> int"""
        return _repycudd.DdManager_FIntersect(self, this_node, g)

    def And(self, this_node, g):
        r"""And(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_And(self, this_node, g)

    def Or(self, this_node, g):
        r"""Or(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_Or(self, this_node, g)

    def Nand(self, this_node, g):
        r"""Nand(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_Nand(self, this_node, g)

    def Nor(self, this_node, g):
        r"""Nor(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_Nor(self, this_node, g)

    def Xor(self, this_node, g):
        r"""Xor(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_Xor(self, this_node, g)

    def Xnor(self, this_node, g):
        r"""Xnor(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_Xnor(self, this_node, g)

    def ClippingAnd(self, this_node, g, maxDepth, direction):
        r"""ClippingAnd(DdManager self, DdNode this_node, DdNode g, int maxDepth, int direction) -> DdNode"""
        return _repycudd.DdManager_ClippingAnd(self, this_node, g, maxDepth, direction)

    def ClippingAndAbstract(self, this_node, g, cube, maxDepth, direction):
        r"""ClippingAndAbstract(DdManager self, DdNode this_node, DdNode g, DdNode cube, int maxDepth, int direction) -> DdNode"""
        return _repycudd.DdManager_ClippingAndAbstract(self, this_node, g, cube, maxDepth, direction)

    def LICompaction(self, this_node, c):
        r"""LICompaction(DdManager self, DdNode this_node, DdNode c) -> DdNode"""
        return _repycudd.DdManager_LICompaction(self, this_node, c)

    def Squeeze(self, this_node, u):
        r"""Squeeze(DdManager self, DdNode this_node, DdNode u) -> DdNode"""
        return _repycudd.DdManager_Squeeze(self, this_node, u)

    def Minimize(self, this_node, c):
        r"""Minimize(DdManager self, DdNode this_node, DdNode c) -> DdNode"""
        return _repycudd.DdManager_Minimize(self, this_node, c)

    def Constrain(self, this_node, c):
        r"""Constrain(DdManager self, DdNode this_node, DdNode c) -> DdNode"""
        return _repycudd.DdManager_Constrain(self, this_node, c)

    def Restrict(self, this_node, c):
        r"""Restrict(DdManager self, DdNode this_node, DdNode c) -> DdNode"""
        return _repycudd.DdManager_Restrict(self, this_node, c)

    def PickOneCube(self, this_node, string):
        r"""PickOneCube(DdManager self, DdNode this_node, char * string) -> int"""
        return _repycudd.DdManager_PickOneCube(self, this_node, string)

    def PickOneMinterm(self, this_node, vars, n):
        r"""PickOneMinterm(DdManager self, DdNode this_node, DdArray vars, int n) -> DdNode"""
        return _repycudd.DdManager_PickOneMinterm(self, this_node, vars, n)

    def PickArbitraryMinterms(self, this_node, vars, n, k):
        r"""PickArbitraryMinterms(DdManager self, DdNode this_node, DdArray vars, int n, int k) -> DdArray"""
        return _repycudd.DdManager_PickArbitraryMinterms(self, this_node, vars, n, k)

    def Compose(self, this_node, g, v):
        r"""Compose(DdManager self, DdNode this_node, DdNode g, int v) -> DdNode"""
        return _repycudd.DdManager_Compose(self, this_node, g, v)

    def Permute(self, this_node, permut):
        r"""Permute(DdManager self, DdNode this_node, IntArray permut) -> DdNode"""
        return _repycudd.DdManager_Permute(self, this_node, permut)

    def VarMap(self, this_node):
        r"""VarMap(DdManager self, DdNode this_node) -> DdNode"""
        return _repycudd.DdManager_VarMap(self, this_node)

    def LiteralSetIntersection(self, this_node, g):
        r"""LiteralSetIntersection(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_LiteralSetIntersection(self, this_node, g)

    def IsVarEssential(self, this_node, id, phase):
        r"""IsVarEssential(DdManager self, DdNode this_node, int id, int phase) -> int"""
        return _repycudd.DdManager_IsVarEssential(self, this_node, id, phase)

    def Leq(self, this_node, g):
        r"""Leq(DdManager self, DdNode this_node, DdNode g) -> bool"""
        return _repycudd.DdManager_Leq(self, this_node, g)

    def CharToVect(self, this_node):
        r"""CharToVect(DdManager self, DdNode this_node) -> DdArray"""
        return _repycudd.DdManager_CharToVect(self, this_node)

    def ConstrainDecomp(self, this_node):
        r"""ConstrainDecomp(DdManager self, DdNode this_node) -> DdArray"""
        return _repycudd.DdManager_ConstrainDecomp(self, this_node)

    def Isop(self, this_node, U):
        r"""Isop(DdManager self, DdNode this_node, DdNode U) -> DdNode"""
        return _repycudd.DdManager_Isop(self, this_node, U)

    def SwapVariables(self, this_node, x, y, n):
        r"""SwapVariables(DdManager self, DdNode this_node, DdArray x, DdArray y, int n) -> DdNode"""
        return _repycudd.DdManager_SwapVariables(self, this_node, x, y, n)

    def AdjPermuteX(self, this_node, x, n):
        r"""AdjPermuteX(DdManager self, DdNode this_node, DdArray x, int n) -> DdNode"""
        return _repycudd.DdManager_AdjPermuteX(self, this_node, x, n)

    def VectorCompose(self, this_node, vector):
        r"""VectorCompose(DdManager self, DdNode this_node, DdArray vector) -> DdNode"""
        return _repycudd.DdManager_VectorCompose(self, this_node, vector)

    def SetBackground(self, this_node):
        r"""SetBackground(DdManager self, DdNode this_node)"""
        return _repycudd.DdManager_SetBackground(self, this_node)

    def UnderApprox(self, this_node, numVars, threshold, safe, quality):
        r"""UnderApprox(DdManager self, DdNode this_node, int numVars, int threshold, int safe, double quality) -> DdNode"""
        return _repycudd.DdManager_UnderApprox(self, this_node, numVars, threshold, safe, quality)

    def OverApprox(self, this_node, numVars, threshold, safe, quality):
        r"""OverApprox(DdManager self, DdNode this_node, int numVars, int threshold, int safe, double quality) -> DdNode"""
        return _repycudd.DdManager_OverApprox(self, this_node, numVars, threshold, safe, quality)

    def RemapUnderApprox(self, this_node, numVars, threshold, quality):
        r"""RemapUnderApprox(DdManager self, DdNode this_node, int numVars, int threshold, double quality) -> DdNode"""
        return _repycudd.DdManager_RemapUnderApprox(self, this_node, numVars, threshold, quality)

    def RemapOverApprox(self, this_node, numVars, threshold, quality):
        r"""RemapOverApprox(DdManager self, DdNode this_node, int numVars, int threshold, double quality) -> DdNode"""
        return _repycudd.DdManager_RemapOverApprox(self, this_node, numVars, threshold, quality)

    def BiasedUnderApprox(self, this_node, b, numVars, threshold, quality1, quality0):
        r"""BiasedUnderApprox(DdManager self, DdNode this_node, DdNode b, int numVars, int threshold, double quality1, double quality0) -> DdNode"""
        return _repycudd.DdManager_BiasedUnderApprox(self, this_node, b, numVars, threshold, quality1, quality0)

    def BiasedOverApprox(self, this_node, b, numVars, threshold, quality1, quality0):
        r"""BiasedOverApprox(DdManager self, DdNode this_node, DdNode b, int numVars, int threshold, double quality1, double quality0) -> DdNode"""
        return _repycudd.DdManager_BiasedOverApprox(self, this_node, b, numVars, threshold, quality1, quality0)

    def Cofactor(self, this_node, g):
        r"""Cofactor(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_Cofactor(self, this_node, g)

    def FindEssential(self, this_node):
        r"""FindEssential(DdManager self, DdNode this_node) -> DdNode"""
        return _repycudd.DdManager_FindEssential(self, this_node)

    def SubsetCompress(self, this_node, nvars, threshold):
        r"""SubsetCompress(DdManager self, DdNode this_node, int nvars, int threshold) -> DdNode"""
        return _repycudd.DdManager_SubsetCompress(self, this_node, nvars, threshold)

    def SupersetCompress(self, this_node, nvars, threshold):
        r"""SupersetCompress(DdManager self, DdNode this_node, int nvars, int threshold) -> DdNode"""
        return _repycudd.DdManager_SupersetCompress(self, this_node, nvars, threshold)

    def CProjection(self, this_node, Y):
        r"""CProjection(DdManager self, DdNode this_node, DdNode Y) -> DdNode"""
        return _repycudd.DdManager_CProjection(self, this_node, Y)

    def MinHammingDist(self, this_node, minterm, upperBound):
        r"""MinHammingDist(DdManager self, DdNode this_node, IntArray minterm, int upperBound) -> int"""
        return _repycudd.DdManager_MinHammingDist(self, this_node, minterm, upperBound)

    def Eval(self, this_node, inputs):
        r"""Eval(DdManager self, DdNode this_node, IntArray inputs) -> DdNode"""
        return _repycudd.DdManager_Eval(self, this_node, inputs)

    def ShortestPath(self, this_node, weight, support, length):
        r"""ShortestPath(DdManager self, DdNode this_node, IntArray weight, IntArray support, IntArray length) -> DdNode"""
        return _repycudd.DdManager_ShortestPath(self, this_node, weight, support, length)

    def LargestCube(self, this_node, length):
        r"""LargestCube(DdManager self, DdNode this_node, IntArray length) -> DdNode"""
        return _repycudd.DdManager_LargestCube(self, this_node, length)

    def ShortestLength(self, this_node, weight):
        r"""ShortestLength(DdManager self, DdNode this_node, IntArray weight) -> int"""
        return _repycudd.DdManager_ShortestLength(self, this_node, weight)

    def Decreasing(self, this_node, i):
        r"""Decreasing(DdManager self, DdNode this_node, int i) -> DdNode"""
        return _repycudd.DdManager_Decreasing(self, this_node, i)

    def Increasing(self, this_node, i):
        r"""Increasing(DdManager self, DdNode this_node, int i) -> DdNode"""
        return _repycudd.DdManager_Increasing(self, this_node, i)

    def EquivDC(self, this_node, G, D):
        r"""EquivDC(DdManager self, DdNode this_node, DdNode G, DdNode D) -> int"""
        return _repycudd.DdManager_EquivDC(self, this_node, G, D)

    def EqualSupNorm(self, this_node, g, tolerance, pr):
        r"""EqualSupNorm(DdManager self, DdNode this_node, DdNode g, CUDD_VALUE_TYPE tolerance, int pr) -> int"""
        return _repycudd.DdManager_EqualSupNorm(self, this_node, g, tolerance, pr)

    def CofMinterm(self, this_node):
        r"""CofMinterm(DdManager self, DdNode this_node) -> DoubleArray"""
        return _repycudd.DdManager_CofMinterm(self, this_node)

    def VerifySol(self, this_node, G, yIndex, n):
        r"""VerifySol(DdManager self, DdNode this_node, DdArray G, IntArray yIndex, int n) -> DdNode"""
        return _repycudd.DdManager_VerifySol(self, this_node, G, yIndex, n)

    def SplitSet(self, this_node, xVars, n, m):
        r"""SplitSet(DdManager self, DdNode this_node, DdArray xVars, int n, double m) -> DdNode"""
        return _repycudd.DdManager_SplitSet(self, this_node, xVars, n, m)

    def SubsetHeavyBranch(self, this_node, numVars, threshold):
        r"""SubsetHeavyBranch(DdManager self, DdNode this_node, int numVars, int threshold) -> DdNode"""
        return _repycudd.DdManager_SubsetHeavyBranch(self, this_node, numVars, threshold)

    def SupersetHeavyBranch(self, this_node, numVars, threshold):
        r"""SupersetHeavyBranch(DdManager self, DdNode this_node, int numVars, int threshold) -> DdNode"""
        return _repycudd.DdManager_SupersetHeavyBranch(self, this_node, numVars, threshold)

    def SubsetShortPaths(self, this_node, numVars, threshold, hardlimit):
        r"""SubsetShortPaths(DdManager self, DdNode this_node, int numVars, int threshold, int hardlimit) -> DdNode"""
        return _repycudd.DdManager_SubsetShortPaths(self, this_node, numVars, threshold, hardlimit)

    def SupersetShortPaths(self, this_node, numVars, threshold, hardlimit):
        r"""SupersetShortPaths(DdManager self, DdNode this_node, int numVars, int threshold, int hardlimit) -> DdNode"""
        return _repycudd.DdManager_SupersetShortPaths(self, this_node, numVars, threshold, hardlimit)

    def BddToCubeArray(self, this_node, y):
        r"""BddToCubeArray(DdManager self, DdNode this_node, IntArray y) -> int"""
        return _repycudd.DdManager_BddToCubeArray(self, this_node, y)

    def PrintMinterm(self, this_node):
        r"""PrintMinterm(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_PrintMinterm(self, this_node)

    def PrintDebug(self, this_node, n, pr):
        r"""PrintDebug(DdManager self, DdNode this_node, int n, int pr) -> int"""
        return _repycudd.DdManager_PrintDebug(self, this_node, n, pr)

    def EstimateCofactor(self, this_node, i, phase):
        r"""EstimateCofactor(DdManager self, DdNode this_node, int i, int phase) -> int"""
        return _repycudd.DdManager_EstimateCofactor(self, this_node, i, phase)

    def CountMinterm(self, this_node, nvars):
        r"""CountMinterm(DdManager self, DdNode this_node, int nvars) -> double"""
        return _repycudd.DdManager_CountMinterm(self, this_node, nvars)

    def Support(self, this_node):
        r"""Support(DdManager self, DdNode this_node) -> DdNode"""
        return _repycudd.DdManager_Support(self, this_node)

    def SupportSize(self, this_node):
        r"""SupportSize(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_SupportSize(self, this_node)

    def Density(self, this_node, nvars):
        r"""Density(DdManager self, DdNode this_node, int nvars) -> double"""
        return _repycudd.DdManager_Density(self, this_node, nvars)

    def BddStore(self, *args):
        r"""
        BddStore(DdManager self, char * ddname, DdNode f, char ** varnames, IntArray auxids, int mode, int varinfo, char * fname, FILE * fp) -> int
        BddStore(DdManager self, DdNode this_node, char * ddname, char ** varnames, IntArray auxids, int mode, int varinfo, char * fname, FILE * fp) -> int
        """
        return _repycudd.DdManager_BddStore(self, *args)

    def IsConstant(self, this_node):
        r"""IsConstant(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_IsConstant(self, this_node)

    def Not(self, this_node):
        r"""Not(DdManager self, DdNode this_node) -> DdNode"""
        return _repycudd.DdManager_Not(self, this_node)

    def NotCond(self, this_node, c):
        r"""NotCond(DdManager self, DdNode this_node, int c) -> DdNode"""
        return _repycudd.DdManager_NotCond(self, this_node, c)

    def Regular(self, this_node):
        r"""Regular(DdManager self, DdNode this_node) -> DdNode"""
        return _repycudd.DdManager_Regular(self, this_node)

    def Complement(self, this_node):
        r"""Complement(DdManager self, DdNode this_node) -> DdNode"""
        return _repycudd.DdManager_Complement(self, this_node)

    def IsComplement(self, this_node):
        r"""IsComplement(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_IsComplement(self, this_node)

    def T(self, this_node):
        r"""T(DdManager self, DdNode this_node) -> DdNode"""
        return _repycudd.DdManager_T(self, this_node)

    def E(self, this_node):
        r"""E(DdManager self, DdNode this_node) -> DdNode"""
        return _repycudd.DdManager_E(self, this_node)

    def V(self, this_node):
        r"""V(DdManager self, DdNode this_node) -> double"""
        return _repycudd.DdManager_V(self, this_node)

    def ReadIndex(self, *args):
        r"""
        ReadIndex(DdManager self, int i) -> int
        ReadIndex(DdManager self, DdNode this_node, int index) -> int
        """
        return _repycudd.DdManager_ReadIndex(self, *args)

    def addExistAbstract(self, this_node, cube):
        r"""addExistAbstract(DdManager self, DdNode this_node, DdNode cube) -> DdNode"""
        return _repycudd.DdManager_addExistAbstract(self, this_node, cube)

    def addUnivAbstract(self, this_node, cube):
        r"""addUnivAbstract(DdManager self, DdNode this_node, DdNode cube) -> DdNode"""
        return _repycudd.DdManager_addUnivAbstract(self, this_node, cube)

    def addOrAbstract(self, this_node, cube):
        r"""addOrAbstract(DdManager self, DdNode this_node, DdNode cube) -> DdNode"""
        return _repycudd.DdManager_addOrAbstract(self, this_node, cube)

    def addFindMax(self, this_node):
        r"""addFindMax(DdManager self, DdNode this_node) -> DdNode"""
        return _repycudd.DdManager_addFindMax(self, this_node)

    def addFindMin(self, this_node):
        r"""addFindMin(DdManager self, DdNode this_node) -> DdNode"""
        return _repycudd.DdManager_addFindMin(self, this_node)

    def addIthBit(self, this_node, bit):
        r"""addIthBit(DdManager self, DdNode this_node, int bit) -> DdNode"""
        return _repycudd.DdManager_addIthBit(self, this_node, bit)

    def addScalarInverse(self, this_node, epsilon):
        r"""addScalarInverse(DdManager self, DdNode this_node, DdNode epsilon) -> DdNode"""
        return _repycudd.DdManager_addScalarInverse(self, this_node, epsilon)

    def addIte(self, this_node, g, h):
        r"""addIte(DdManager self, DdNode this_node, DdNode g, DdNode h) -> DdNode"""
        return _repycudd.DdManager_addIte(self, this_node, g, h)

    def addIteConstant(self, this_node, g, h):
        r"""addIteConstant(DdManager self, DdNode this_node, DdNode g, DdNode h) -> DdNode"""
        return _repycudd.DdManager_addIteConstant(self, this_node, g, h)

    def addEvalConst(self, this_node, g):
        r"""addEvalConst(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_addEvalConst(self, this_node, g)

    def addLeq(self, this_node, g):
        r"""addLeq(DdManager self, DdNode this_node, DdNode g) -> int"""
        return _repycudd.DdManager_addLeq(self, this_node, g)

    def addCmpl(self, this_node):
        r"""addCmpl(DdManager self, DdNode this_node) -> DdNode"""
        return _repycudd.DdManager_addCmpl(self, this_node)

    def addNegate(self, this_node):
        r"""addNegate(DdManager self, DdNode this_node) -> DdNode"""
        return _repycudd.DdManager_addNegate(self, this_node)

    def addRoundOff(self, this_node, N):
        r"""addRoundOff(DdManager self, DdNode this_node, int N) -> DdNode"""
        return _repycudd.DdManager_addRoundOff(self, this_node, N)

    def addCompose(self, this_node, g, v):
        r"""addCompose(DdManager self, DdNode this_node, DdNode g, int v) -> DdNode"""
        return _repycudd.DdManager_addCompose(self, this_node, g, v)

    def addPermute(self, this_node, permut):
        r"""addPermute(DdManager self, DdNode this_node, IntArray permut) -> DdNode"""
        return _repycudd.DdManager_addPermute(self, this_node, permut)

    def addConstrain(self, this_node, c):
        r"""addConstrain(DdManager self, DdNode this_node, DdNode c) -> DdNode"""
        return _repycudd.DdManager_addConstrain(self, this_node, c)

    def addRestrict(self, this_node, c):
        r"""addRestrict(DdManager self, DdNode this_node, DdNode c) -> DdNode"""
        return _repycudd.DdManager_addRestrict(self, this_node, c)

    def addMatrixMultiply(self, this_node, B, z, nz):
        r"""addMatrixMultiply(DdManager self, DdNode this_node, DdNode B, DdArray z, int nz) -> DdNode"""
        return _repycudd.DdManager_addMatrixMultiply(self, this_node, B, z, nz)

    def addTimesPlus(self, this_node, B, z, nz):
        r"""addTimesPlus(DdManager self, DdNode this_node, DdNode B, DdArray z, int nz) -> DdNode"""
        return _repycudd.DdManager_addTimesPlus(self, this_node, B, z, nz)

    def addTriangle(self, this_node, g, z, nz):
        r"""addTriangle(DdManager self, DdNode this_node, DdNode g, DdArray z, int nz) -> DdNode"""
        return _repycudd.DdManager_addTriangle(self, this_node, g, z, nz)

    def addVectorCompose(self, this_node, vector):
        r"""addVectorCompose(DdManager self, DdNode this_node, DdArray vector) -> DdNode"""
        return _repycudd.DdManager_addVectorCompose(self, this_node, vector)

    def addNonSimCompose(self, this_node, vector):
        r"""addNonSimCompose(DdManager self, DdNode this_node, DdArray vector) -> DdNode"""
        return _repycudd.DdManager_addNonSimCompose(self, this_node, vector)

    def addSwapVariables(self, this_node, x, y, n):
        r"""addSwapVariables(DdManager self, DdNode this_node, DdArray x, DdArray y, int n) -> DdNode"""
        return _repycudd.DdManager_addSwapVariables(self, this_node, x, y, n)

    def zddProduct(self, this_node, g):
        r"""zddProduct(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_zddProduct(self, this_node, g)

    def zddUnateProduct(self, this_node, g):
        r"""zddUnateProduct(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_zddUnateProduct(self, this_node, g)

    def zddWeakDiv(self, this_node, g):
        r"""zddWeakDiv(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_zddWeakDiv(self, this_node, g)

    def zddDivide(self, this_node, g):
        r"""zddDivide(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_zddDivide(self, this_node, g)

    def zddWeakDivF(self, this_node, g):
        r"""zddWeakDivF(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_zddWeakDivF(self, this_node, g)

    def zddDivideF(self, this_node, g):
        r"""zddDivideF(DdManager self, DdNode this_node, DdNode g) -> DdNode"""
        return _repycudd.DdManager_zddDivideF(self, this_node, g)

    def zddComplement(self, this_node):
        r"""zddComplement(DdManager self, DdNode this_node) -> DdNode"""
        return _repycudd.DdManager_zddComplement(self, this_node)

    def zddIte(self, this_node, g, h):
        r"""zddIte(DdManager self, DdNode this_node, DdNode g, DdNode h) -> DdNode"""
        return _repycudd.DdManager_zddIte(self, this_node, g, h)

    def zddUnion(self, this_node, Q):
        r"""zddUnion(DdManager self, DdNode this_node, DdNode Q) -> DdNode"""
        return _repycudd.DdManager_zddUnion(self, this_node, Q)

    def zddIntersect(self, this_node, Q):
        r"""zddIntersect(DdManager self, DdNode this_node, DdNode Q) -> DdNode"""
        return _repycudd.DdManager_zddIntersect(self, this_node, Q)

    def zddDiff(self, this_node, Q):
        r"""zddDiff(DdManager self, DdNode this_node, DdNode Q) -> DdNode"""
        return _repycudd.DdManager_zddDiff(self, this_node, Q)

    def zddDiffConst(self, this_node, Q):
        r"""zddDiffConst(DdManager self, DdNode this_node, DdNode Q) -> DdNode"""
        return _repycudd.DdManager_zddDiffConst(self, this_node, Q)

    def zddSubset1(self, this_node, var):
        r"""zddSubset1(DdManager self, DdNode this_node, int var) -> DdNode"""
        return _repycudd.DdManager_zddSubset1(self, this_node, var)

    def zddSubset0(self, this_node, var):
        r"""zddSubset0(DdManager self, DdNode this_node, int var) -> DdNode"""
        return _repycudd.DdManager_zddSubset0(self, this_node, var)

    def zddChange(self, this_node, var):
        r"""zddChange(DdManager self, DdNode this_node, int var) -> DdNode"""
        return _repycudd.DdManager_zddChange(self, this_node, var)

    def zddCount(self, this_node):
        r"""zddCount(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_zddCount(self, this_node)

    def zddCountDouble(self, this_node):
        r"""zddCountDouble(DdManager self, DdNode this_node) -> double"""
        return _repycudd.DdManager_zddCountDouble(self, this_node)

    def zddPrintMinterm(self, this_node):
        r"""zddPrintMinterm(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_zddPrintMinterm(self, this_node)

    def zddPrintCover(self, this_node):
        r"""zddPrintCover(DdManager self, DdNode this_node) -> int"""
        return _repycudd.DdManager_zddPrintCover(self, this_node)

    def zddPrintDebug(self, this_node, n, pr):
        r"""zddPrintDebug(DdManager self, DdNode this_node, int n, int pr) -> int"""
        return _repycudd.DdManager_zddPrintDebug(self, this_node, n, pr)

    def zddCountMinterm(self, this_node, path):
        r"""zddCountMinterm(DdManager self, DdNode this_node, int path) -> double"""
        return _repycudd.DdManager_zddCountMinterm(self, this_node, path)

    def zddIsop(self, this_node, U, zdd_I):
        r"""zddIsop(DdManager self, DdNode this_node, DdNode U, DdArray zdd_I) -> DdNode"""
        return _repycudd.DdManager_zddIsop(self, this_node, U, zdd_I)

    def ApaPrintMinterm(self, this_node, fp, nvars):
        r"""ApaPrintMinterm(DdManager self, DdNode this_node, FILE * fp, int nvars) -> int"""
        return _repycudd.DdManager_ApaPrintMinterm(self, this_node, fp, nvars)

    def ApaPrintMintermExp(self, this_node, fp, nvars, precision):
        r"""ApaPrintMintermExp(DdManager self, DdNode this_node, FILE * fp, int nvars, int precision) -> int"""
        return _repycudd.DdManager_ApaPrintMintermExp(self, this_node, fp, nvars, precision)

    def ApaPrintDensity(self, this_node, fp, nvars):
        r"""ApaPrintDensity(DdManager self, DdNode this_node, FILE * fp, int nvars) -> int"""
        return _repycudd.DdManager_ApaPrintDensity(self, this_node, fp, nvars)

    def ApaCountMinterm(self, this_node, nvars, digits):
        r"""ApaCountMinterm(DdManager self, DdNode this_node, int nvars, IntArray digits) -> DdApaNumber"""
        return _repycudd.DdManager_ApaCountMinterm(self, this_node, nvars, digits)

    def DumpDot(self, *args):
        r"""
        DumpDot(DdManager self, int n, DdArray f, char ** inames, char ** onames, FILE * fp) -> int
        DumpDot(DdManager self, DdNode this_node) -> int
        """
        return _repycudd.DdManager_DumpDot(self, *args)

    def DumpBlif(self, *args):
        r"""
        DumpBlif(DdManager self, int n, DdArray f, char ** inames, char ** onames, char * mname, FILE * fp, int mv) -> int
        DumpBlif(DdManager self, DdNode this_node) -> int
        """
        return _repycudd.DdManager_DumpBlif(self, *args)

    def Vector(self, this_node):
        r"""Vector(DdManager self, DdNode this_node) -> DdArray"""
        return _repycudd.DdManager_Vector(self, this_node)

# Register DdManager in _repycudd:
_repycudd.DdManager_swigregister(DdManager)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class DdGen(object):
    r"""Proxy of C++ DdGen class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    __doc__ = "Not expected to be used directly."


    def __init__(self, ddman, node1, method, node2=None):
        r"""__init__(DdGen self, DdManager ddman, DdNode node1, int method, DdNode node2=None) -> DdGen"""
        _repycudd.DdGen_swiginit(self, _repycudd.new_DdGen(ddman, node1, method, node2))
    __swig_destroy__ = _repycudd.delete_DdGen

# Register DdGen in _repycudd:
_repycudd.DdGen_swigregister(DdGen)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class DdNode(object):
    r"""Proxy of C++ DdNode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __deepcopy__(self,memo):
      return self
    __doc__ = "This class wraps around the basic DdNode. The methods defined by this class take the default manager as their DdManager option (if needed) and provide themselves as the first DdNode option that those functions require, as indicated by the self argument. These functions may be found in ddnode.i."


    def __init__(self):
        r"""__init__(DdNode self) -> DdNode"""
        _repycudd.DdNode_swiginit(self, _repycudd.new_DdNode())
    __swig_destroy__ = _repycudd.delete_DdNode

    def FirstCube(self, gen, mgr):
        r"""FirstCube(DdNode self, DdGen gen, DdManager mgr) -> int"""
        return _repycudd.DdNode_FirstCube(self, gen, mgr)

    def NextCube(self, gen, mgr):
        r"""NextCube(DdNode self, DdGen gen, DdManager mgr) -> int"""
        return _repycudd.DdNode_NextCube(self, gen, mgr)

    def FirstNode(self, gen):
        r"""FirstNode(DdNode self, DdGen gen) -> int"""
        return _repycudd.DdNode_FirstNode(self, gen)

    def NextNode(self, gen):
        r"""NextNode(DdNode self, DdGen gen) -> int"""
        return _repycudd.DdNode_NextNode(self, gen)

    def CountPathsToNonZero(self):
        r"""CountPathsToNonZero(DdNode self) -> double"""
        return _repycudd.DdNode_CountPathsToNonZero(self)

    def NodeReadIndex(self):
        r"""NodeReadIndex(DdNode self) -> int"""
        return _repycudd.DdNode_NodeReadIndex(self)

    def IsNonConstant(self):
        r"""IsNonConstant(DdNode self) -> int"""
        return _repycudd.DdNode_IsNonConstant(self)

    def DagSize(self):
        r"""DagSize(DdNode self) -> int"""
        return _repycudd.DdNode_DagSize(self)

    def EstimateCofactorSimple(self, i):
        r"""EstimateCofactorSimple(DdNode self, int i) -> int"""
        return _repycudd.DdNode_EstimateCofactorSimple(self, i)

    def CountPath(self):
        r"""CountPath(DdNode self) -> double"""
        return _repycudd.DdNode_CountPath(self)

    def CountLeaves(self):
        r"""CountLeaves(DdNode self) -> int"""
        return _repycudd.DdNode_CountLeaves(self)

    def IsConstant(self):
        r"""IsConstant(DdNode self) -> int"""
        return _repycudd.DdNode_IsConstant(self)

    def Not(self):
        r"""Not(DdNode self) -> DdNode"""
        return _repycudd.DdNode_Not(self)

    def NotCond(self, c):
        r"""NotCond(DdNode self, int c) -> DdNode"""
        return _repycudd.DdNode_NotCond(self, c)

    def Regular(self):
        r"""Regular(DdNode self) -> DdNode"""
        return _repycudd.DdNode_Regular(self)

    def Complement(self):
        r"""Complement(DdNode self) -> DdNode"""
        return _repycudd.DdNode_Complement(self)

    def IsComplement(self):
        r"""IsComplement(DdNode self) -> int"""
        return _repycudd.DdNode_IsComplement(self)

    def T(self):
        r"""T(DdNode self) -> DdNode"""
        return _repycudd.DdNode_T(self)

    def E(self):
        r"""E(DdNode self) -> DdNode"""
        return _repycudd.DdNode_E(self)

    def V(self):
        r"""V(DdNode self) -> double"""
        return _repycudd.DdNode_V(self)

    def zddDagSize(self, p_node):
        r"""zddDagSize(DdNode self, DdNode p_node) -> int"""
        return _repycudd.DdNode_zddDagSize(self, p_node)

    def __hash__(self):
        r"""__hash__(DdNode self) -> int"""
        return _repycudd.DdNode___hash__(self)

    def __int__(self):
        r"""__int__(DdNode self) -> int"""
        return _repycudd.DdNode___int__(self)

    def __cmp__(self, other):
        r"""__cmp__(DdNode self, DdNode other) -> bool"""
        return _repycudd.DdNode___cmp__(self, other)

    def __eq__(self, other):
        r"""__eq__(DdNode self, DdNode other) -> bool"""
        return _repycudd.DdNode___eq__(self, other)

    def __ne__(self, other):
        r"""__ne__(DdNode self, DdNode other) -> bool"""
        return _repycudd.DdNode___ne__(self, other)

    def __len__(self):
        r"""__len__(DdNode self) -> int"""
        return _repycudd.DdNode___len__(self)

    def SizeOf(self):
        r"""SizeOf(DdNode self) -> int"""
        return _repycudd.DdNode_SizeOf(self)

# Register DdNode in _repycudd:
_repycudd.DdNode_swigregister(DdNode)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class NodePair(object):
    r"""Proxy of C++ NodePair class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __iter__(self):
      global iter_meth
      if iter_meth != 2:
        print("Can only enumerate primes for a NodePair. Setting iter_meth == 2 and proceeding")
        iter_meth = 2
      return ForeachPrimeIterator(self)
    __doc__="This is used to provide the functionality of prime enumeration in CUDD 2.4.0. Create the NodePair by passing the DdNodes for lower and upper to the constructor. Once that is done, you can iterate over the primes of the NodePair using the Python for statement. There is no need to do this if you are interested in the primes of a simple DdNode -- the package automatically creates the NodePair and destroys it in that case."



    def __init__(self, lwr, upr):
        r"""__init__(NodePair self, DdNode lwr, DdNode upr) -> NodePair"""
        _repycudd.NodePair_swiginit(self, _repycudd.new_NodePair(lwr, upr))
    __swig_destroy__ = _repycudd.delete_NodePair

    def LOWER(self):
        r"""LOWER(NodePair self) -> DdNode"""
        return _repycudd.NodePair_LOWER(self)

    def UPPER(self):
        r"""UPPER(NodePair self) -> DdNode"""
        return _repycudd.NodePair_UPPER(self)

    def FirstPrime(self, gen, mgr):
        r"""FirstPrime(NodePair self, DdGen gen, DdManager mgr) -> int"""
        return _repycudd.NodePair_FirstPrime(self, gen, mgr)

    def NextPrime(self, gen, mgr):
        r"""NextPrime(NodePair self, DdGen gen, DdManager mgr) -> int"""
        return _repycudd.NodePair_NextPrime(self, gen, mgr)

# Register NodePair in _repycudd:
_repycudd.NodePair_swigregister(NodePair)


cudd_version = 0x020400


###############################
#
# iter_meth is used to set, surprise, the iteration method for DdNodes
# 0 -- over cubes
# 1 -- over nodes
# 2 -- over primes
# Note that iteration over primes is only available in CUDD >= 2.4.0
#
################################
iter_meth = 0

def set_iter_meth(meth,verbose = False):
  global iter_meth
  methods = ["cubes", "nodes", "primes"]
  if verbose:
     print("Setting iter method to iterate over %s", methods[meth])
  iter_meth = meth

class ForeachCubeIterator:
    def __init__(self,mgr,Dd):
        self.gen = DdGen(mgr,Dd,iter_meth)
        self.node = Dd
        self.done = 0
        self.mgr = mgr
        self.ret_val = Dd.FirstCube(self.gen,self.mgr)
        if not self.ret_val[0]: self.done = 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.done: raise StopIteration
        to_ret = self.ret_val[1:]
        self.ret_val = self.node.NextCube(self.gen,self.mgr)
        if not self.ret_val[0]:
          self.done = 1
        return to_ret
    next = __next__ # Python 2.7

class ForeachNodeIterator:
    def __init__(self,mgr,Dd):
        self.gen = DdGen(mgr,Dd,iter_meth)
        self.node = Dd
        self.done = 0
        self.ret_val = Dd.FirstNode(self.gen)
        if not self.ret_val[0]: self.done = 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.done: raise StopIteration
        to_ret = self.ret_val[1]
        self.ret_val = self.node.NextNode(self.gen)
        if not self.ret_val[0]:
            self.done = 1
        return to_ret
    next = __next__ # Python 2.7

class ForeachPrimeIterator:
    def __init__(self,mgr,npair):
        global cudd_version
        if cudd_version < 0x020400:
            print("CUDD versions < 2.4.0 do not support iteration over primes")
            raise RuntimeError
        self.gen = DdGen(mgr,npair.LOWER(), iter_meth, npair.UPPER())
        self.npair = npair
        self.done = 0
        self.ret_val = npair.FirstPrime(self.gen)
        if not self.ret_val[0]: self.done = 1
    def __iter__(self):
        return self

    def __next__(self):
        if self.done: raise StopIteration
        to_ret = self.ret_val[1:]
        self.ret_val = self.npair.NextPrime(self.gen)
        if not self.ret_val[0]:
            self.done = 1
        return to_ret
    next = __next__ # Python 2.7

def cube_tuple_to_str(cube_tup):
    res = ""
    for char in cube_tup:
        if char == 2: res += '-'
        else: res += str(char)
    return res



